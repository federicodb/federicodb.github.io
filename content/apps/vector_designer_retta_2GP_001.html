<!DOCTYPE html>
<html lang="it" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <title>The Vector Artist | Geometria Analitica v3.3</title>
    <!-- Shared Orfini Design System -->
    <link rel="stylesheet" href="../assets/style/orfini-shared.css">
    <script src="../assets/js/orfini-shared.js"></script>

    <meta name="description" content="Attività per l'esplorazione interattiva delle forme dell'equazione della retta e per lo studio del suo grafico.">
    <meta name="keywords" content="Matematica, Retta, Parallelismo, Perpendicolarità, Punto, Piano Cartesiano, Forma Implicita, Forma Esplicita, 1EL, 2EL, Mat:Calcolo, EU:ImparareImparare, Gamification, Geometria Analitica, Modello Lineare">

  

    <!-- STACK TECNOLOGICO -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@0.294.0/dist/umd/lucide.min.js"></script>

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        brand: { 500: '#06b6d4', 600: '#0891b2', 700: '#0e7490' },
                        accent: { 500: '#d946ef', 600: '#c026d3', 700: '#a21caf' }
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['Fira Code', 'monospace'],
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600&family=Inter:wght@400;700;900&display=swap');
        
        body { transition: background-color 0.3s ease, color 0.3s ease; }
        
        /* --- SLIDER CUSTOMIZATION (HIGH VISIBILITY) --- */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
            height: 24px; /* Touch target larger */
            cursor: pointer;
        }
        
        /* Track Styling */
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; 
            height: 6px; 
            border-radius: 3px;
            transition: background 0.3s;
        }
        .dark input[type=range]::-webkit-slider-runnable-track { background: #334155; }
        html:not(.dark) input[type=range]::-webkit-slider-runnable-track { background: #cbd5e1; }

        /* Thumb Styling */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; 
            height: 20px; 
            width: 20px; 
            border-radius: 50%;
            border: 2px solid;
            margin-top: -7px; /* Centers thumb on track */
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        input[type=range]:active::-webkit-slider-thumb { transform: scale(1.2); }

        .dark input[type=range]::-webkit-slider-thumb { background: #0f172a; border-color: currentColor; }
        html:not(.dark) input[type=range]::-webkit-slider-thumb { background: #ffffff; border-color: currentColor; }

        /* Input Number Clean */
        input[type=text].math-input {
            -moz-appearance: textfield; 
            font-family: 'Fira Code', monospace; 
            text-align: center;
        }

        .glass-panel { backdrop-filter: blur(12px); }
        .fade-in { animation: fadeIn 0.4s cubic-bezier(0.16, 1, 0.3, 1); }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body class="bg-background text-on-background dark:bg-slate-950 dark:text-slate-200">
    <div id="app"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;
        
        // --- UTILS: SMART INPUT COMPONENT ---
        const SmartInput = ({ value, onChange, className }) => {
            const [textVal, setTextVal] = useState(String(value));

            useEffect(() => {
                const parsedText = parseFloat(textVal);
                if (parsedText !== value && !(textVal === '' || textVal === '-')) {
                    setTextVal(String(value));
                }
            }, [value]);

            const handleChange = (e) => {
                const v = e.target.value;
                if (/^-?\d*\.?\d*$/.test(v)) {
                    setTextVal(v);
                    const parsed = parseFloat(v);
                    if (!isNaN(parsed)) onChange(parsed);
                }
            };

            const handleBlur = () => {
                const parsed = parseFloat(textVal);
                if (isNaN(parsed)) setTextVal(String(value));
                else { setTextVal(String(parsed)); onChange(parsed); }
            };

            return (
                <input type="text" value={textVal} onChange={handleChange} onBlur={handleBlur} className={`math-input transition-colors outline-none ${className}`} inputMode="decimal" />
            );
        };

        // --- ICONS ---
        const IconLine = ({className}) => (<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="4" y1="20" x2="20" y2="4" /><circle cx="12" cy="12" r="2" fill="currentColor" stroke="none" /></svg>);
        const IconImplicit = ({className}) => (<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect x="4" y="4" width="16" height="16" rx="2" /><path d="M8 12h8" /><path d="M12 8v8" /></svg>);
        const IconPoints = ({className}) => (<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="6" cy="18" r="3" fill="currentColor"/><circle cx="18" cy="6" r="3" fill="currentColor"/><line x1="6" y1="18" x2="18" y2="6" strokeDasharray="4 4" opacity="0.5"/></svg>);
        const IconParallel = ({className}) => (<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="4" y1="20" x2="16" y2="4" /><line x1="10" y1="20" x2="22" y2="4" stroke="currentColor" /></svg>);
        const IconPerp = ({className}) => (<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="4" y1="20" x2="20" y2="4" opacity="0.5" strokeDasharray="4 4"/><line x1="20" y1="20" x2="4" y2="4" /><path d="M16 16 L12 12 L8 16" fill="none" strokeWidth="1" opacity="0.5"/></svg>);

        const LucideIcon = ({ name, size = 24, className = "" }) => {
            const ref = useRef(null);
            useEffect(() => {
                if (ref.current && window.lucide && window.lucide.icons[name]) {
                    ref.current.innerHTML = '';
                    const iconNode = lucide.createElement(lucide.icons[name]);
                    iconNode.setAttribute('width', size);
                    iconNode.setAttribute('height', size);
                    iconNode.setAttribute('class', className);
                    ref.current.appendChild(iconNode);
                }
            }, [name, size, className]);
            return <span ref={ref} className="inline-flex items-center justify-center" style={{width: size, height: size}} />;
        };

        const Icons = {
            User: (p) => <LucideIcon name="User" {...p} />,
            Gamepad2: (p) => <LucideIcon name="Gamepad2" {...p} />,
            Trophy: (p) => <LucideIcon name="Trophy" {...p} />,
            CheckCircle: (p) => <LucideIcon name="CheckCircle" {...p} />,
            XCircle: (p) => <LucideIcon name="XCircle" {...p} />,
            RefreshCw: (p) => <LucideIcon name="RefreshCw" {...p} />,
            ZoomIn: (p) => <LucideIcon name="ZoomIn" {...p} />,
            ZoomOut: (p) => <LucideIcon name="ZoomOut" {...p} />,
            Focus: (p) => <LucideIcon name="Focus" {...p} />,
            Settings: (p) => <LucideIcon name="Settings" {...p} />,
            Wand2: (p) => <LucideIcon name="Wand2" {...p} />,
            Lock: (p) => <LucideIcon name="Lock" {...p} />,
            Target: (p) => <LucideIcon name="Target" {...p} />,
            Brain: (p) => <LucideIcon name="Brain" {...p} />,
            PenTool: (p) => <LucideIcon name="PenTool" {...p} />,
            LogOut: (p) => <LucideIcon name="LogOut" {...p} />,
            Sun: (p) => <LucideIcon name="Sun" {...p} />,
            Moon: (p) => <LucideIcon name="Moon" {...p} />,
            Plus: (p) => <LucideIcon name="Plus" {...p} />,
            Minus: (p) => <LucideIcon name="Minus" {...p} />,
        };

        // --- MATH ENGINE ---
        const generateTarget = (difficulty, mode) => {
            const randomSign = () => Math.random() > 0.5 ? 1 : -1;
            const getM = () => {
                if (difficulty === 'base') return (Math.floor(Math.random() * 3) + 1) * randomSign();
                if (difficulty === 'intermedio') return ((Math.floor(Math.random() * 4) + 1) / 2) * randomSign();
                return Math.round((Math.random() * 6 - 3) * 10) / 10;
            };
            const getQ = () => {
                if (difficulty === 'base' || difficulty === 'intermedio') return Math.floor(Math.random() * 5) * randomSign();
                return Math.floor(Math.random() * 8) * randomSign();
            };

            let m = getM(), q = getQ();
            let a = 1, b = -1, c = 0;

            if (mode === 'implicit') {
                a = (Math.floor(Math.random() * 3) + 1) * randomSign();
                b = (Math.floor(Math.random() * 3) + 1) * randomSign();
                c = Math.floor(Math.random() * 6) * randomSign();
                m = -a/b; q = -c/b;
            }

            let x1 = Math.floor(Math.random() * 4) * randomSign();
            let x2 = x1 + (2 + Math.floor(Math.random() * 3)) * (x1 > 0 ? -1 : 1);
            let y1 = m * x1 + q;
            let y2 = m * x2 + q;

            let refLine = null, refPoint = null;
            if (mode === 'parallel' || mode === 'perpendicular') {
                let refM;
                if (mode === 'parallel') refM = m; 
                else { refM = getM() || 1; m = -1 / refM; }
                refLine = { m: refM, q: Math.floor(Math.random() * 5) * randomSign() };
                const px = Math.floor(Math.random() * 4) * randomSign();
                const py = Math.floor(Math.random() * 4) * randomSign();
                refPoint = { x: px, y: py };
                q = py - (m * px);
            }
            return { m, q, a, b, c, p1: {x:x1, y:y1}, p2: {x:x2, y:y2}, refLine, refPoint };
        };

        // --- UI COMPONENT: CONTROL ROW ---
        const ControlRow = ({ label, value, onChange, min, max, step, colorClass, labelColor }) => {
            
            const handleStep = (delta) => {
                const nextVal = Math.min(max, Math.max(min, parseFloat((value + delta).toFixed(1))));
                onChange(nextVal);
            };

            return (
                <div className="bg-background dark:bg-slate-900/50 p-3 rounded-xl border border-outline-variant dark:border-slate-800 space-y-2 shadow-sm">
                    {/* Header: Label + Input */}
                    <div className="flex justify-between items-center">
                        <span className={`font-bold text-sm ${labelColor}`}>{label}</span>
                        <SmartInput 
                            value={value} 
                            onChange={onChange} 
                            className={`w-20 rounded bg-surface dark:bg-slate-800 border border-slate-300 dark:border-slate-600 text-on-background dark:text-white py-1 font-bold shadow-inner ${labelColor}`} 
                        />
                    </div>
                    
                    {/* Controls: [-] Slider [+] */}
                    <div className="flex items-center gap-3">
                        <button onClick={() => handleStep(-step)} className="p-2 rounded-lg bg-surface-variant dark:bg-slate-800 hover:bg-slate-300 dark:hover:bg-slate-700 text-slate-600 dark:text-slate-400 transition active:scale-95 shadow-sm">
                            <Icons.Minus size={16} />
                        </button>
                        
                        <div className="flex-1 relative flex items-center h-6">
                            <input 
                                type="range" 
                                min={min} max={max} step={step} 
                                value={value} 
                                onChange={e => onChange(parseFloat(e.target.value))} 
                                className={`w-full ${colorClass}`}
                            />
                        </div>

                        <button onClick={() => handleStep(step)} className="p-2 rounded-lg bg-surface-variant dark:bg-slate-800 hover:bg-slate-300 dark:hover:bg-slate-700 text-slate-600 dark:text-slate-400 transition active:scale-95 shadow-sm">
                            <Icons.Plus size={16} />
                        </button>
                    </div>
                </div>
            );
        };

        // --- APP COMPONENTS ---

        const WelcomeScreen = ({ onStart, leaderboard, theme, toggleTheme }) => {
            const [name, setName] = useState('');
            const [diff, setDiff] = useState('base');

            return (
                <div className="h-screen w-full flex flex-col items-center justify-center p-6 bg-background dark:bg-slate-950 relative overflow-hidden transition-colors">
                    <div className="absolute inset-0 opacity-10 dark:opacity-20 bg-[radial-gradient(#64748b_1px,transparent_1px)] [background-size:20px_20px]"></div>
                    <button onClick={toggleTheme} className="absolute top-4 right-4 z-20 p-2 bg-surface dark:bg-slate-800 rounded-full shadow border border-outline-variant dark:border-slate-700 text-outline-variant dark:text-yellow-400 hover:scale-110 transition">
                        {theme === 'dark' ? <Icons.Sun size={20} /> : <Icons.Moon size={20} />}
                    </button>
                    <div className="relative z-10 w-full max-w-md space-y-8 fade-in text-center">
                        <div className="flex justify-center">
                            <div className="p-6 bg-surface dark:bg-slate-900 rounded-2xl border border-outline-variant dark:border-cyan-500/30 shadow-2xl shadow-cyan-500/10">
                                <Icons.PenTool size={48} className="text-brand-600 dark:text-cyan-400" />
                            </div>
                        </div>
                        <div>
                            <h1 className="text-4xl font-black text-on-background dark:text-white tracking-tight">VECTOR <span className="text-brand-600 dark:text-cyan-400">ARTIST</span></h1>
                            <p className="text-outline-variant dark:text-slate-400 font-mono text-sm mt-2">v3.3 | Orfini Math Lab</p>
                        </div>
                        <div className="bg-white/80 dark:bg-slate-900/80 glass-panel p-6 rounded-2xl space-y-4 text-left border border-outline-variant dark:border-slate-800 shadow-xl">
                            <div>
                                <label className="text-xs font-bold text-outline-variant dark:text-slate-400 uppercase ml-1">Nome Agente</label>
                                <div className="flex items-center gap-3 bg-surface-container dark:bg-slate-950 p-3 rounded-xl border border-slate-300 dark:border-slate-700 mt-1 focus-within:border-brand-500 dark:focus-within:border-cyan-500 transition-colors">
                                    <Icons.User size={20} className="text-outline-variant dark:text-slate-500" />
                                    <input type="text" value={name} onChange={(e) => setName(e.target.value)} placeholder="Inserisci il tuo nome..." className="bg-transparent border-none outline-none text-on-background dark:text-white w-full font-mono placeholder-slate-400" />
                                </div>
                            </div>
                            <div>
                                <label className="text-xs font-bold text-outline-variant dark:text-slate-400 uppercase ml-1">Livello</label>
                                <div className="grid grid-cols-3 gap-2 mt-1">
                                    {['base', 'intermedio', 'avanzato'].map(d => (
                                        <button key={d} onClick={() => setDiff(d)} className={`py-2 text-xs font-bold rounded-lg capitalize border transition-all ${diff === d ? 'bg-brand-100 dark:bg-cyan-900/30 border-brand-500 dark:border-cyan-500 text-brand-700 dark:text-cyan-400' : 'bg-slate-100 dark:bg-slate-950 border-outline-variant dark:border-slate-800 text-outline-variant hover:bg-slate-200 dark:hover:bg-slate-800'}`}>{d}</button>
                                    ))}
                                </div>
                            </div>
                            <button onClick={() => name.trim() && onStart(name, diff)} disabled={!name.trim()} className="w-full py-4 bg-brand-600 hover:bg-brand-500 dark:bg-cyan-600 dark:hover:bg-cyan-500 disabled:opacity-50 disabled:cursor-not-allowed text-on-background font-black text-lg rounded-xl shadow-lg shadow-brand-500/20 dark:shadow-cyan-500/20 transition-all active:scale-95 flex items-center justify-center gap-2 mt-4">
                                <Icons.Gamepad2 size={20} /> INIZIA MISSIONE
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const MissionReport = ({ score, playerName, onRestart }) => (
            <div className="h-screen w-full flex flex-col items-center justify-center bg-background dark:bg-slate-950 fade-in p-6 transition-colors">
                 <div className="bg-white/90 dark:bg-slate-900/90 glass-panel p-8 rounded-3xl text-center max-w-md w-full border border-outline-variant dark:border-cyan-500/50 shadow-2xl relative overflow-hidden">
                    <div className="absolute top-0 left-0 w-full h-2 bg-gradient-to-r from-brand-500 via-accent-500 to-brand-500 animate-pulse"></div>
                    <Icons.CheckCircle size={64} className="text-emerald-500 mx-auto mb-6" />
                    <h2 className="text-3xl font-black text-on-background dark:text-white mb-2">MISSIONE COMPLETATA</h2>
                    <p className="text-outline-variant dark:text-slate-400 font-mono mb-8">Ottimo lavoro, Agente {playerName}.</p>
                    <div className="bg-surface-container dark:bg-slate-950 p-6 rounded-2xl mb-8 border border-outline-variant dark:border-slate-800">
                        <div className="text-xs text-outline-variant uppercase tracking-widest mb-1">Punteggio Totale</div>
                        <div className="text-5xl font-black text-transparent bg-clip-text bg-gradient-to-r from-brand-600 to-accent-600 dark:from-cyan-400 dark:to-fuchsia-400">{score} XP</div>
                    </div>
                    <button onClick={onRestart} className="w-full py-4 bg-surface dark:bg-white text-on-background dark:text-slate-900 font-bold rounded-xl hover:opacity-90 transition flex items-center justify-center gap-2">
                        <Icons.RefreshCw size={20} /> NUOVA MISSIONE
                    </button>
                 </div>
            </div>
        );

        const GameScreen = ({ playerName, difficulty, onExit, onFinishMission, theme }) => {
            const canvasRef = useRef(null);
            const [view, setView] = useState({ scale: 1, x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            const dragStart = useRef({ x: 0, y: 0 });
            const [round, setRound] = useState(1);
            const MAX_ROUNDS = 3;
            const [mode, setMode] = useState('explicit'); 
            const [target, setTarget] = useState(null);
            const [userM, setUserM] = useState(1);
            const [userQ, setUserQ] = useState(0);
            const [userA, setUserA] = useState(1);
            const [userB, setUserB] = useState(-1);
            const [userC, setUserC] = useState(0);
            const [score, setScore] = useState(0);
            const [feedback, setFeedback] = useState(null);
            const [scaffolding, setScaffolding] = useState(false);
            const [aiHint, setAiHint] = useState("");

            const MODES = useMemo(() => [
                {id:'explicit', label: 'Retta', icon: IconLine}, 
                {id:'implicit', label: 'Implicita', icon: IconImplicit}, 
                {id:'points', label: '2 Punti', icon: IconPoints}, 
                {id:'parallel', label: 'Parallela', icon: IconParallel}, 
                {id:'perpendicular', label: 'Perpend.', icon: IconPerp}
            ], []);

            useEffect(() => { startLevel(); }, [difficulty, mode]);

            const startLevel = () => {
                setTarget(generateTarget(difficulty, mode));
                setFeedback(null);
                setScaffolding(false);
                setAiHint("");
                setView({ scale: 1, x: 0, y: 0 });
                setUserM(1); setUserQ(0);
                setUserA(1); setUserB(-1); setUserC(0);
            };

            const switchMode = (newMode) => {
                if (mode === newMode) return;
                setMode(newMode);
                setRound(1);
                setScore(0);
            };

            const nextRound = () => {
                if (round < MAX_ROUNDS) { setRound(r => r + 1); startLevel(); } 
                else { onFinishMission(score); }
            };

            const resetView = () => setView({ scale: 1, x: 0, y: 0 });
            const zoomIn = () => setView(v => ({ ...v, scale: Math.min(v.scale * 1.2, 5) }));
            const zoomOut = () => setView(v => ({ ...v, scale: Math.max(v.scale / 1.2, 0.5) }));
            const handleMouseDown = (e) => { setIsDragging(true); dragStart.current = { x: e.clientX - view.x, y: e.clientY - view.y }; };
            const handleMouseMove = (e) => { if(isDragging) setView(v => ({ ...v, x: e.clientX - dragStart.current.x, y: e.clientY - dragStart.current.y })); };
            const handleMouseUp = () => setIsDragging(false);

            // --- SQUARE GRID LOGIC ---
            const mapX = (x, w, h) => {
                const unit = Math.min(w, h) / 20; 
                return w/2 + (x * unit * view.scale) + view.x;
            };
            const mapY = (y, w, h) => {
                const unit = Math.min(w, h) / 20;
                return h/2 - (y * unit * view.scale) + view.y;
            };

            const toggleScaffolding = () => {
                if (!scaffolding) {
                    let hint = "Analisi in corso... ";
                    let currM = (mode === 'implicit' && userB !== 0) ? -userA/userB : userM;
                    let currQ = (mode === 'implicit' && userB !== 0) ? -userC/userB : userQ;
                    const mDiff = currM - target.m;
                    const qDiff = currQ - target.q;
                    if (mode === 'parallel') hint = `Obiettivo: Parallela a m=${target.refLine.m}. Attuale: m=${currM.toFixed(1)}.`;
                    else if (mode === 'perpendicular') hint = `Obiettivo: Perpendicolare a m=${target.refLine.m}. Cerca l'antireciproco (-1/m).`;
                    else if (Math.abs(mDiff) > 0.1) hint += currM > target.m ? "Troppo Ripida/Negativa." : "Troppo Piatta.";
                    else if (Math.abs(qDiff) > 0.1) hint += "Inclinazione OK. Centra il punto.";
                    else hint = "Parametri geometricamente validi.";
                    setAiHint(hint);
                }
                setScaffolding(!scaffolding);
            };

            const checkAnswer = () => {
                if(!target) return;
                let currM = (mode === 'implicit' && userB !== 0) ? -userA/userB : userM;
                let currQ = (mode === 'implicit' && userB !== 0) ? -userC/userB : userQ;
                const tol = 0.2;
                if (Math.abs(currM - target.m) < tol && Math.abs(currQ - target.q) < tol) {
                    const basePoints = 1000;
                    const penalty = scaffolding ? 0.7 : 1;
                    const roundPoints = Math.floor(basePoints * penalty);
                    setScore(s => s + roundPoints);
                    setFeedback({ type: 'success', msg: `Round Superato! +${roundPoints} XP` });
                    setTimeout(nextRound, 2000);
                } else {
                    setFeedback({ type: 'error', msg: "Allineamento fallito. Riprova." });
                }
            };

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas || !target) return;
                const ctx = canvas.getContext('2d');
                const w = canvas.width = canvas.offsetWidth;
                const h = canvas.height = canvas.offsetHeight;
                const isDark = theme === 'dark';
                const colBg = isDark ? '#0f172a' : '#f8fafc'; 
                const colGrid = isDark ? '#1e293b' : '#e2e8f0'; 
                const colAxes = isDark ? '#64748b' : '#94a3b8'; 
                const colUser = isDark ? '#06b6d4' : '#0891b2'; 
                const colRef = isDark ? '#d946ef' : '#c026d3'; 
                const colTarget = '#f59e0b'; 

                ctx.fillStyle = colBg; ctx.fillRect(0,0,w,h);
                ctx.strokeStyle = colGrid; 
                ctx.lineWidth = view.scale > 1.5 ? 2 : 1;
                ctx.beginPath();
                for(let i=-20; i<=20; i++){
                    ctx.moveTo(mapX(i,w,h), 0); ctx.lineTo(mapX(i,w,h), h);
                    ctx.moveTo(0, mapY(i,w,h)); ctx.lineTo(w, mapY(i,w,h));
                }
                ctx.stroke();

                ctx.strokeStyle = colAxes; ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(mapX(0,w,h), 0); ctx.lineTo(mapX(0,w,h), h);
                ctx.moveTo(0, mapY(0,w,h)); ctx.lineTo(w, mapY(0,w,h));
                ctx.stroke();

                if ((mode === 'parallel' || mode === 'perpendicular') && target.refLine) {
                    ctx.save();
                    ctx.strokeStyle = colRef; ctx.setLineDash([8,8]); ctx.lineWidth = 2;
                    ctx.beginPath();
                    const yStart = target.refLine.m * (-20) + target.refLine.q;
                    const yEnd = target.refLine.m * (20) + target.refLine.q;
                    ctx.moveTo(mapX(-20,w,h), mapY(yStart,w,h));
                    ctx.lineTo(mapX(20,w,h), mapY(yEnd,w,h));
                    ctx.stroke();
                    ctx.restore();
                    const p = target.refPoint;
                    ctx.fillStyle = colRef;
                    ctx.beginPath(); ctx.arc(mapX(p.x,w,h), mapY(p.y,w,h), 6, 0, Math.PI*2); ctx.fill();
                    ctx.font="bold 12px Inter";
                    const txt = `P(${p.x},${p.y})`;
                    ctx.fillStyle = isDark ? colBg : '#fff';
                    ctx.fillText(txt, mapX(p.x,w,h)+10, mapY(p.y,w,h)-10);
                    ctx.fillStyle = isDark ? '#fff' : '#0f172a';
                    ctx.fillText(txt, mapX(p.x,w,h)+10, mapY(p.y,w,h)-10);
                }

                if (mode !== 'parallel' && mode !== 'perpendicular') {
                    if (mode === 'points') {
                        ctx.fillStyle = colTarget;
                        [target.p1, target.p2].forEach(p => {
                            ctx.beginPath(); ctx.arc(mapX(p.x,w,h), mapY(p.y,w,h), 5, 0, Math.PI*2); ctx.fill();
                        });
                    }
                    ctx.save();
                    ctx.strokeStyle = isDark ? 'rgba(217, 70, 239, 0.4)' : 'rgba(192, 38, 211, 0.4)'; 
                    ctx.setLineDash([5,5]); ctx.lineWidth = 3;
                    ctx.beginPath();
                    const yS = target.m * (-20) + target.q;
                    const yE = target.m * (20) + target.q;
                    ctx.moveTo(mapX(-20,w,h), mapY(yS,w,h)); ctx.lineTo(mapX(20,w,h), mapY(yE,w,h));
                    ctx.stroke();
                    ctx.restore();
                }

                ctx.save();
                ctx.strokeStyle = colUser; ctx.lineWidth = 3; 
                if(isDark) { ctx.shadowColor = colUser; ctx.shadowBlur = 10; }
                ctx.beginPath();
                let currM = (mode === 'implicit' && userB !== 0) ? -userA/userB : userM;
                let currQ = (mode === 'implicit' && userB !== 0) ? -userC/userB : userQ;
                const yUS = currM * (-20) + currQ;
                const yUE = currM * (20) + currQ;
                ctx.moveTo(mapX(-20,w,h), mapY(yUS,w,h)); ctx.lineTo(mapX(20,w,h), mapY(yUE,w,h));
                ctx.stroke();
                ctx.restore();
            }, [target, userM, userQ, userA, userB, userC, mode, view, theme]);

            return (
                <div className="h-screen w-full flex flex-col lg:flex-row bg-background dark:bg-slate-950 transition-colors">
                    {/* LEFT: CANVAS */}
                    <div className="flex-1 relative flex flex-col p-2 bg-surface-container dark:bg-slate-900 overflow-hidden">
                        <div className="absolute top-4 left-4 right-4 flex justify-between z-20 pointer-events-none">
                            <div className="bg-white/90 dark:bg-slate-900/90 p-2 rounded-xl border border-outline-variant dark:border-slate-700 pointer-events-auto flex gap-2 shadow-sm">
                                <button onClick={onExit} className="hover:bg-red-50 text-outline-variant dark:text-slate-400 hover:text-red-500 transition p-1 rounded-lg flex items-center gap-2 px-3 text-sm font-bold"><Icons.LogOut size={16} /> ESCI</button>
                                <span className="font-mono text-on-background dark:text-white px-2 border-l border-outline-variant dark:border-slate-600 flex items-center font-bold">ROUND {round}/3</span>
                            </div>
                            <div className="bg-white/90 dark:bg-slate-900/90 px-4 py-2 rounded-xl border border-brand-200 dark:border-cyan-500/50 text-brand-600 dark:text-cyan-400 font-black text-xl shadow-sm">{score} XP</div>
                        </div>
                        <div className="absolute top-24 left-4 z-20 flex flex-col gap-2">
                            {MODES.map(m => (
                                <button key={m.id} onClick={() => switchMode(m.id)} title={m.label} className={`p-3 rounded-xl transition-all border shadow-sm ${mode === m.id ? 'bg-brand-600 dark:bg-cyan-500 text-on-background border-transparent' : 'bg-white dark:bg-slate-800 text-outline-variant hover:text-brand-500 dark:hover:text-white border-outline-variant dark:border-slate-700'}`}>
                                    <m.icon className="w-6 h-6" />
                                </button>
                            ))}
                        </div>
                        {(mode === 'parallel' || mode === 'perpendicular') && target?.refLine && (
                            <div className="absolute bottom-6 left-1/2 -translate-x-1/2 z-20 bg-white/90 dark:bg-slate-900/90 border border-accent-500 dark:border-fuchsia-500 p-3 rounded-xl flex items-center gap-3 shadow-xl backdrop-blur-md">
                                <Icons.Target className="text-accent-600 dark:text-fuchsia-500 animate-pulse" />
                                <div>
                                    <div className="text-[10px] text-accent-600 dark:text-fuchsia-500 font-bold uppercase tracking-wider mb-0.5">TARGET</div>
                                    <div className="font-mono text-on-background dark:text-white text-lg">Rif: <span className="text-accent-600 dark:text-fuchsia-400 font-bold">y = {target.refLine.m}x {target.refLine.q >= 0 ? '+' : ''}{target.refLine.q}</span></div>
                                </div>
                            </div>
                        )}
                        <div className="absolute bottom-6 right-6 z-20 flex flex-col gap-2 bg-white/90 dark:bg-slate-800/90 p-2 rounded-xl border border-outline-variant dark:border-slate-700 backdrop-blur shadow-lg">
                            <button onClick={zoomIn} className="p-2 hover:bg-slate-100 dark:hover:bg-slate-700 rounded text-slate-600 dark:text-white"><Icons.ZoomIn size={20}/></button>
                            <button onClick={resetView} className="p-2 hover:bg-slate-100 dark:hover:bg-slate-700 rounded text-brand-600 dark:text-cyan-400"><Icons.Focus size={20}/></button>
                            <button onClick={zoomOut} className="p-2 hover:bg-slate-100 dark:hover:bg-slate-700 rounded text-slate-600 dark:text-white"><Icons.ZoomOut size={20}/></button>
                        </div>
                        <canvas ref={canvasRef} onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} className="w-full h-full cursor-move rounded-xl border border-outline-variant dark:border-slate-800 shadow-inner bg-surface dark:bg-[#0f172a]" />
                        {feedback && (
                            <div className={`absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 px-8 py-6 rounded-2xl border-2 shadow-2xl z-30 flex flex-col items-center gap-3 backdrop-blur-xl animate-bounce ${feedback.type === 'success' ? 'bg-emerald-100 dark:bg-emerald-900/90 border-emerald-500 text-emerald-700 dark:text-emerald-100' : 'bg-red-100 dark:bg-red-900/90 border-red-500 text-red-700 dark:text-red-100'}`}>
                                {feedback.type === 'success' ? <Icons.CheckCircle size={48} /> : <Icons.XCircle size={48} />}
                                <span className="font-black text-2xl">{String(feedback.msg)}</span>
                            </div>
                        )}
                        {scaffolding && aiHint && (
                            <div className="absolute top-20 right-4 max-w-xs bg-brand-50/90 dark:bg-cyan-950/90 border border-brand-200 dark:border-cyan-500/50 p-4 rounded-xl text-brand-800 dark:text-cyan-200 text-sm font-mono shadow-xl z-20 backdrop-blur">
                                <div className="flex items-center gap-2 font-bold mb-2 border-b border-brand-200 dark:border-cyan-500/30 pb-2"><Icons.Brain size={16}/> ANALISI</div>{String(aiHint)}
                            </div>
                        )}
                    </div>

                    {/* RIGHT: CONTROLS */}
                    <div className="w-full lg:w-96 bg-surface dark:bg-slate-950 border-l border-outline-variant dark:border-slate-800 p-6 flex flex-col shadow-2xl z-30 overflow-y-auto">
                        <div className="mb-6">
                            <h3 className="font-bold flex items-center gap-2 uppercase text-sm text-outline-variant mb-4"><Icons.Settings size={14}/> Console Comandi</h3>
                            
                            {mode !== 'implicit' ? (
                                <div className="space-y-6">
                                    <ControlRow 
                                        label="M (Pendenza)" value={userM} onChange={setUserM} min={-10} max={10} step={0.1}
                                        colorClass="accent-brand-600 dark:accent-cyan-500" labelColor="text-brand-600 dark:text-cyan-400"
                                    />
                                    <ControlRow 
                                        label="Q (Quota)" value={userQ} onChange={setUserQ} min={-20} max={20} step={0.5}
                                        colorClass="accent-amber-500 dark:accent-amber-500" labelColor="text-amber-500 dark:text-amber-500"
                                    />
                                </div>
                            ) : (
                                <div className="space-y-6">
                                    <ControlRow label="a" value={userA} onChange={setUserA} min={-10} max={10} step={1} colorClass="accent-brand-600 dark:accent-cyan-500" labelColor="text-brand-600 dark:text-cyan-400"/>
                                    <ControlRow label="b" value={userB} onChange={setUserB} min={-10} max={10} step={1} colorClass="accent-accent-600 dark:accent-fuchsia-400" labelColor="text-accent-600 dark:text-fuchsia-400"/>
                                    <ControlRow label="c" value={userC} onChange={setUserC} min={-20} max={20} step={1} colorClass="accent-amber-500 dark:accent-amber-500" labelColor="text-amber-500 dark:text-amber-500"/>
                                </div>
                            )}
                        </div>

                        <div className="mt-auto space-y-3">
                            <button onClick={toggleScaffolding} className={`w-full py-3 rounded-xl border flex items-center justify-center gap-2 transition text-xs font-bold uppercase tracking-wider ${scaffolding ? 'border-brand-500 dark:border-cyan-500 bg-brand-50 dark:bg-cyan-500/10 text-brand-600 dark:text-cyan-400' : 'border-slate-200 dark:border-slate-800 bg-surface-container dark:bg-slate-900 text-outline-variant hover:bg-slate-200 dark:hover:bg-slate-800'}`}>
                                <Icons.Wand2 size={16} /> {scaffolding ? 'AI Online (-30%)' : 'Richiedi AI'}
                            </button>
                            <button onClick={checkAnswer} className="w-full py-4 bg-gradient-to-r from-brand-600 to-blue-600 dark:from-cyan-600 dark:to-blue-600 rounded-xl text-on-background font-black text-lg shadow-lg hover:scale-[1.02] active:scale-95 transition-transform flex items-center justify-center gap-2">
                                <Icons.Lock size={20} /> ESEGUI
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [screen, setScreen] = useState('welcome');
            const [userData, setUserData] = useState({ name: '', diff: 'base' });
            const [leaderboard, setLeaderboard] = useState([]);
            const [finalScore, setFinalScore] = useState(0);
            const [theme, setTheme] = useState('dark');

            useEffect(() => {
                const root = document.documentElement;
                if(theme === 'dark') root.classList.add('dark');
                else root.classList.remove('dark');
            }, [theme]);

            const toggleTheme = () => setTheme(prev => prev === 'dark' ? 'light' : 'dark');

            useEffect(() => {
                try {
                    const saved = JSON.parse(localStorage.getItem('vectorArtist_lb') || '[]');
                    if (Array.isArray(saved) && saved.every(i => i && typeof i === 'object')) setLeaderboard(saved.sort((a,b) => b.score - a.score));
                    else throw new Error("Corrupted Data");
                } catch(e) { localStorage.removeItem('vectorArtist_lb'); setLeaderboard([]); }
            }, []);

            const saveScore = (score) => {
                setFinalScore(score);
                const newEntry = { name: userData.name, score, date: new Date().toLocaleDateString() };
                const newLb = [...leaderboard, newEntry].sort((a,b) => b.score - a.score).slice(0, 10);
                setLeaderboard(newLb);
                localStorage.setItem('vectorArtist_lb', JSON.stringify(newLb));
                setScreen('report');
            };

            return (
                <>
                    {screen === 'welcome' && <WelcomeScreen onStart={(n,d) => { setUserData({name:n, diff:d}); setScreen('game'); }} leaderboard={leaderboard} theme={theme} toggleTheme={toggleTheme} />}
                    {screen === 'game' && <GameScreen playerName={userData.name} difficulty={userData.diff} onExit={() => setScreen('welcome')} onFinishMission={saveScore} theme={theme} />}
                    {screen === 'report' && <MissionReport score={finalScore} playerName={userData.name} onRestart={() => setScreen('welcome')} />}
                </>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('app'));
        root.render(<App />);
    </script>
</body>
</html>