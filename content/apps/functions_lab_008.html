<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    
    <!-- 1. META DATI -->
    <title>Studio di Funzioni: Lab Analisi + AI</title>
    <!-- Shared Orfini Design System -->
    <link rel="stylesheet" href="../assets/style/orfini-shared.css">
    <script src="../assets/js/orfini-shared.js"></script>

    <meta name="description" content="Suite completa per lo studio di funzioni reali: dominio, simmetrie, classificazione e composizione. Grafici interattivi e analisi in tempo reale powered by Gemini.">
    <meta name="keywords" content="Matematica, Analisi, Funzioni, Studio di Funzione, Grafici, Dominio, AI, Gemini, Education">
    <meta name="date" content="2025-12-10">

    <!-- 2. FIX MOBILE -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- Librerie -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- Configurazione Tailwind -->
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        neon: {
                            blue: '#00f3ff',
                            pink: '#ff00ff',
                            green: '#00ff9d',
                            purple: '#bd00ff',
                            yellow: '#faff00',
                            orange: '#ff9e00',
                            red: '#ff2a2a'
                        },
                        amoled: '#000000',
                        darkgray: '#0a0a0a'
                    },
                    fontFamily: {
                        mono: ['"JetBrains Mono"', 'monospace'],
                        sans: ['"Inter"', 'sans-serif']
                    },
                    cursor: { crosshair: 'crosshair' }
                }
            }
        }
    </script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">

    <style>
        /* CSS FULLSCREEN */
        html, body {
            font-family: 'Inter', sans-serif;
            margin: 0; padding: 0;
            width: 100vw; height: 100dvh;
            overflow: hidden;
            position: fixed;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        .font-mono { font-family: 'JetBrains Mono', monospace; }
        
        /* Utility */
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        .neon-glow { filter: drop-shadow(0 0 5px currentColor); }
        .trace-line { stroke-linecap: round; stroke-linejoin: round; transition: stroke-dashoffset 0.1s linear; }
        .skull-shadow { filter: drop-shadow(0 2px 4px rgba(0,0,0,0.8)); }
        
        /* Slider Custom */
        input[type=range] { -webkit-appearance: none; background: transparent; cursor: pointer; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%;
            background: #ffffff; border: 2px solid #6366f1; margin-top: -8px;
            box-shadow: 0 0 10px rgba(99, 102, 241, 0.5); transition: transform 0.1s;
        }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.2); }
        .dark input[type=range]::-webkit-slider-thumb {
            background: #00f3ff; border: 2px solid #ffffff; box-shadow: 0 0 15px #00f3ff;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; background: rgba(148, 163, 184, 0.3); border-radius: 2px;
        }

        /* Glass Input */
        .input-glass {
            background: rgba(255,255,255,0.8);
            backdrop-filter: blur(8px);
        }
        .dark .input-glass {
            background: rgba(10,10,10,0.8);
        }

        /* Animation Keyframes */
        @keyframes pulse-subtle {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .animate-pulse-subtle { animation: pulse-subtle 3s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        
        @keyframes sparkle {
            0% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.2); filter: brightness(1.3); }
            100% { transform: scale(1); filter: brightness(1); }
        }
        .animate-sparkle { animation: sparkle 2s infinite ease-in-out; }
    </style>
</head>
<body class="bg-background dark:bg-amoled text-slate-900 dark:text-slate-100 transition-colors duration-500">
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // --- GEMINI API HELPER ---
        const runGemini = async (prompt, systemInstruction = "") => {
            const apiKey = ""; // Set at runtime by the environment
            
            // Retry logic with exponential backoff
            const fetchWithRetry = async (retries = 3, delay = 1000) => {
                try {
                    const response = await fetch(
                        `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
                        {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: prompt }] }],
                                systemInstruction: { parts: [{ text: systemInstruction }] }
                            }),
                        }
                    );
                    
                    if (!response.ok) {
                         // Se Ã¨ un errore server o rate limit, riprova
                         if ((response.status >= 500 || response.status === 429) && retries > 0) {
                             await new Promise(r => setTimeout(r, delay));
                             return fetchWithRetry(retries - 1, delay * 2);
                         }
                         throw new Error(`Errore API Gemini: ${response.status}`);
                    }
                    return response;
                } catch (e) {
                    if (retries > 0) {
                        await new Promise(r => setTimeout(r, delay));
                        return fetchWithRetry(retries - 1, delay * 2);
                    }
                    throw e;
                }
            };

            try {
                const response = await fetchWithRetry();
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "Nessuna risposta.";
            } catch (error) {
                console.error("Gemini Error:", error);
                return "Non sono riuscito a contattare l'AI. Riprova piÃ¹ tardi.";
            }
        };

        // --- COMPONENTS ---
        const Icon = ({ name, size = 20, className }) => {
            useEffect(() => { lucide.createIcons(); }, [name]);
            return <i data-lucide={name} width={size} height={size} className={className}></i>;
        };

        // --- MATH ENGINE ---
        const parseFunctionString = (expression) => {
            try {
                if (!expression) return null;
                let norm = expression.toLowerCase().replace(/\s+/g, '');
                
                // Ordine importante: funzioni piÃ¹ lunghe prima per evitare match parziali
                const mathFunctions = ['asin', 'acos', 'atan', 'sqrt', 'log', 'exp', 'abs', 'sin', 'cos', 'tan', 'pow', 'floor', 'ceil', 'round', 'sign', 'max', 'min', 'pi', 'e'];
                const tokens = {};
                
                mathFunctions.forEach(fn => {
                    const token = `@${fn.toUpperCase()}@`;
                    if (fn === 'pi') tokens[token] = 'Math.PI';
                    else if (fn === 'e') tokens[token] = 'Math.E';
                    else tokens[token] = `Math.${fn}`;
                    
                    norm = norm.split(fn).join(token);
                });

                norm = norm.replace(/\^/g, '**');
                norm = norm.replace(/(\d)(?=[a-z@\(])/g, '$1*'); // 2x -> 2*x
                norm = norm.replace(/([a-z])(?=[a-z@\(])/g, '$1*'); 
                norm = norm.replace(/(\))(?=[\d a-z@])/g, '$1*'); // )2 -> )*2
                
                Object.keys(tokens).forEach(token => { norm = norm.split(token).join(tokens[token]); });
                
                return new Function('x', `try { return (${norm}); } catch { return NaN; }`);
            } catch (e) { return null; }
        };

        // --- ANALYSIS ENGINE (Numerical) ---
        const analyzeFunctionProperties = (fn, view) => {
            if (!fn) return null;
            
            const analysis = {
                zeros: [],
                yIntercept: null,
                minPoints: [],
                maxPoints: [],
                domainLabel: "R (100%)", 
                domainCoverage: 100 
            };

            try {
                // 1. Y-Intercept
                try {
                    const y0 = fn(0);
                    if (!isNaN(y0) && isFinite(y0)) analysis.yIntercept = y0;
                } catch(e) {}

                // 2. Numerical Scan
                const steps = 200; // Increased resolution
                const dx = (view.xMax - view.xMin) / steps;
                let validPoints = 0;
                let prevY = null;
                let prevSlope = null;
                
                const exclusions = []; // Store potential discontinuities

                for (let i = 0; i <= steps; i++) {
                    const x = view.xMin + i * dx;
                    let y;
                    try { y = fn(x); } catch { y = NaN; }
                    
                    const isValid = !isNaN(y) && isFinite(y);

                    if (isValid) {
                        validPoints++;
                        
                        // Root Finding
                        if (prevY !== null && Math.sign(prevY) !== Math.sign(y) && Math.abs(prevY - y) < (view.yMax - view.yMin)/2) {
                            const zeroX = x - dx * (y / (y - prevY));
                            analysis.zeros.push(zeroX);
                        }

                        // Derivative & Extrema
                        const yNext = (() => { try { return fn(x + 0.001); } catch { return NaN; } })();
                        if (!isNaN(yNext) && isFinite(yNext)) {
                            const slope = (yNext - y) / 0.001;
                            if (prevSlope !== null && !isNaN(prevSlope) && Math.sign(prevSlope) !== Math.sign(slope)) {
                                if (Math.abs(slope) < 50 && Math.abs(prevSlope) < 50) { 
                                    if (prevSlope > 0 && slope < 0) analysis.maxPoints.push({x, y});
                                    else if (prevSlope < 0 && slope > 0) analysis.minPoints.push({x, y});
                                }
                            }
                            prevSlope = slope;
                        }
                    }

                    // Exclusion Detection (Singularity or Asymptote)
                    const isJump = isValid && prevY !== null && Math.abs(y - prevY) > (view.yMax - view.yMin); 
                    
                    if (!isValid || isJump) {
                        exclusions.push(x);
                    }

                    if (isValid) prevY = y;
                    else prevY = null; 
                }
                
                analysis.domainCoverage = Math.round((validPoints / steps) * 100);

                // Process Exclusions
                if (exclusions.length > 0) {
                    const uniqueExclusions = [];
                    const threshold = (view.xMax - view.xMin) / 20; 
                    
                    let cluster = [exclusions[0]];
                    for(let i=1; i<exclusions.length; i++) {
                        if(exclusions[i] - exclusions[i-1] < threshold) {
                            cluster.push(exclusions[i]);
                        } else {
                            const avg = cluster.reduce((a,b)=>a+b,0)/cluster.length;
                            uniqueExclusions.push(avg);
                            cluster = [exclusions[i]];
                        }
                    }
                    if(cluster.length>0) {
                         const avg = cluster.reduce((a,b)=>a+b,0)/cluster.length;
                         uniqueExclusions.push(avg);
                    }

                    const formatted = uniqueExclusions
                        .map(x => Math.abs(x) < 0.1 ? "0" : x.toFixed(1)) 
                        .map(x => `x â‰  ${x}`)
                        .join(", ");
                    
                    if (uniqueExclusions.length > 3) analysis.domainLabel = `x â‰  ... (${uniqueExclusions.length} punti)`;
                    else analysis.domainLabel = formatted;
                } else {
                    analysis.domainLabel = "R (Tutto)";
                }

            } catch (e) { console.error("Analysis Error", e); }

            return analysis;
        };


        // --- UI COMPONENTS ---
        const MathInput = ({ value, onChange, placeholder, label="f(x)", onMagicClick }) => (
            <div className="relative group flex items-center w-full input-glass border border-slate-300 dark:border-slate-700 rounded-xl focus-within:border-indigo-500 dark:focus-within:border-neon-blue focus-within:ring-1 focus-within:ring-indigo-500/50 transition-all duration-200 overflow-hidden shadow-sm">
                <div className="px-3 py-3 bg-slate-100 dark:bg-white/5 border-r border-slate-200 dark:border-slate-700 flex items-center justify-center select-none min-w-[50px]">
                    <span className="font-mono font-bold text-lg text-indigo-600 dark:text-neon-blue italic tracking-tight">
                        {label}=
                    </span>
                </div>
                <input
                    type="text"
                    value={value}
                    onChange={onChange}
                    className="flex-1 bg-transparent border-none outline-none px-3 py-3 font-mono text-lg text-slate-800 dark:text-slate-100 placeholder-slate-400 dark:placeholder-slate-600 w-full min-w-0"
                    placeholder={placeholder}
                    spellCheck="false"
                    autoComplete="off"
                />
                {onMagicClick && (
                    <button 
                        onClick={onMagicClick}
                        className="p-3 hover:bg-indigo-50 dark:hover:bg-white/10 text-indigo-500 dark:text-neon-blue transition-colors border-l border-slate-200 dark:border-slate-700 group/magic"
                        title="Genera con AI"
                    >
                        <Icon name="sparkles" size={20} className="group-hover/magic:animate-sparkle" />
                    </button>
                )}
            </div>
        );

        const AnalysisPanel = ({ data, visible, currentFunctionStr }) => {
            const [aiExplanation, setAiExplanation] = useState(null);
            const [loading, setLoading] = useState(false);

            useEffect(() => { setAiExplanation(null); }, [currentFunctionStr]); 

            const handleAskAI = async () => {
                if(!data) return;
                setLoading(true);
                const prompt = `Analizza questa funzione: f(x) = ${currentFunctionStr}. 
                Dati numerici rilevati: Dominio: ${data.domainLabel}, Zeri: [${data.zeros.map(z=>z.toFixed(2)).join(', ')}], Intercetta Y: ${data.yIntercept}.
                Spiega brevemente in italiano le caratteristiche salienti del grafico basandoti su questi dati. 
                IMPORTANTE:
                1. Sii estremamente sintetico (max 3 frasi).
                2. NON usare mai blocchi di codice, backticks (\`) o formattazione LaTeX.
                3. Usa il carattere # come punto elenco.
                4. Sii discorsivo e didattico.`;
                
                let response = await runGemini(prompt, "Sei un professore di analisi matematica gentile, chiaro e sintetico. Rispondi solo in plain text.");
                // Frontend cleanup
                response = response.replace(/`/g, '').replace(/\*\*/g, '').replace(/###/g, '');
                setAiExplanation(response);
                setLoading(false);
            };

            if (!visible || !data) return null;
            return (
                <div className="absolute top-4 right-4 w-72 bg-white/90 dark:bg-black/80 backdrop-blur-md border border-slate-200 dark:border-slate-800 rounded-2xl p-4 shadow-xl z-10 text-xs font-mono transition-all duration-300 animate-fadeIn max-h-[80vh] overflow-y-auto hide-scrollbar">
                    <h4 className="font-bold text-slate-900 dark:text-white mb-2 flex items-center justify-between border-b border-slate-200 dark:border-slate-700 pb-2">
                        <span className="flex items-center gap-2"><Icon name="activity" size={14} className="text-indigo-600 dark:text-neon-blue"/> ANALISI VISTA</span>
                        <button 
                            onClick={handleAskAI} 
                            disabled={loading}
                            className="bg-indigo-100 dark:bg-indigo-900/50 hover:bg-indigo-200 dark:hover:bg-indigo-900 text-indigo-700 dark:text-indigo-300 px-2 py-1 rounded flex items-center gap-1 transition-colors disabled:opacity-50"
                        >
                            <Icon name="sparkles" size={12}/> {loading ? '...' : 'CHIEDI A GEMINI'}
                        </button>
                    </h4>
                    
                    <div className="space-y-2 text-slate-600 dark:text-slate-300 mb-3">
                        <div className="flex justify-between items-start">
                            <span>Dominio:</span>
                            <span className={`text-right font-bold ${data.domainLabel.includes('â‰ ') ? "text-amber-500" : "text-green-500"}`}>{data.domainLabel}</span>
                        </div>
                        
                        <div className="flex justify-between">
                            <span>Intercetta Y:</span>
                            <span className="text-slate-900 dark:text-white">{data.yIntercept !== null ? data.yIntercept.toFixed(2) : 'N/A'}</span>
                        </div>

                        <div>
                            <span className="block mb-1">Zeri (approssimati):</span>
                            <div className="flex flex-wrap gap-1">
                                {data.zeros.length > 0 ? data.zeros.slice(0, 3).map((z, i) => (
                                    <span key={i} className="bg-slate-200 dark:bg-slate-800 px-1.5 py-0.5 rounded text-slate-900 dark:text-white">{z.toFixed(2)}</span>
                                )) : <span className="text-slate-400">-</span>}
                                {data.zeros.length > 3 && <span className="text-slate-400">...</span>}
                            </div>
                        </div>

                        {(data.maxPoints.length > 0 || data.minPoints.length > 0) && (
                             <div>
                                <span className="block mb-1">Punti Stazionari:</span>
                                <div className="space-y-1">
                                    {data.maxPoints.slice(0,1).map((p,i) => <div key={'max'+i} className="text-red-500">MAX: ({p.x.toFixed(1)}, {p.y.toFixed(1)})</div>)}
                                    {data.minPoints.slice(0,1).map((p,i) => <div key={'min'+i} className="text-green-500">MIN: ({p.x.toFixed(1)}, {p.y.toFixed(1)})</div>)}
                                </div>
                             </div>
                        )}
                    </div>

                    {aiExplanation && (
                        <div className="mt-3 pt-3 border-t border-slate-200 dark:border-slate-700 animate-fadeIn">
                            <div className="flex items-center gap-2 mb-1 text-indigo-600 dark:text-neon-purple font-bold">
                                <Icon name="bot" size={14}/> Tutor AI
                            </div>
                            <div className="text-slate-700 dark:text-slate-300 leading-relaxed italic bg-indigo-50 dark:bg-white/5 p-2 rounded-lg whitespace-pre-wrap">
                                {aiExplanation}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- GRAPH ENGINE ---
        const mapRange = (value, inMin, inMax, outMin, outMax) => ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;

        // Funzione per calcolare step "belli" (1, 2, 5, 10...)
        const getNiceStep = (range) => {
            const roughStep = range / 6; // Voglio circa 6 tick
            const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
            const normalizedStep = roughStep / magnitude;
            
            let niceStep;
            if (normalizedStep < 1.5) niceStep = 1;
            else if (normalizedStep < 3) niceStep = 2;
            else if (normalizedStep < 7) niceStep = 5;
            else niceStep = 10;
            
            return niceStep * magnitude;
        };

        const GraphEngine = ({ 
            funcs = [], interactive = true, showHorizontalTest = false, highlightDomain = false,
            showCodomain = false, enableCrosshair = true, overlayText = null, enableSlider = true,
            showGrid = true, showAnalysis = false, currentFunctionStr = "", showIntersections = false
        }) => {
            const containerRef = useRef(null);
            const [dims, setDims] = useState({ w: 1, h: 1 }); 
            const [view, setView] = useState({ xMin: -10, xMax: 10, yMin: -10, yMax: 10 });
            const [dragging, setDragging] = useState(false);
            const [lastPos, setLastPos] = useState({ x: 0, y: 0 });
            const [sliderX, setSliderX] = useState(0);
            const [cursor, setCursor] = useState(null);
            const [analysisData, setAnalysisData] = useState(null);

            // Auto-scale "Smart"
            useEffect(() => {
                if (funcs.length > 0 && funcs[0].fn) {
                    const fn = funcs[0].fn;
                    let yMin = Infinity, yMax = -Infinity;
                    
                    const scanRange = 10;
                    for (let x = -scanRange; x <= scanRange; x += 0.5) {
                        try {
                            const y = fn(x);
                            if (!isNaN(y) && isFinite(y)) {
                                if (y < yMin) yMin = y;
                                if (y > yMax) yMax = y;
                            }
                        } catch(e) {}
                    }
                    
                    if (yMin === Infinity) { yMin = -5; yMax = 5; }
                    if (Math.abs(yMax - yMin) < 1) { yMin -= 5; yMax += 5; }
                    
                    const padding = Math.max(2, (yMax - yMin) * 0.2);
                    const safeYMin = Math.max(yMin, -50);
                    const safeYMax = Math.min(yMax, 50);

                    setView({ xMin: -10, xMax: 10, yMin: safeYMin - padding, yMax: safeYMax + padding });
                    setSliderX(0);
                }
            }, [funcs[0]?.fn]);

            // Analisi in tempo reale (Debounced)
            useEffect(() => {
                if ((showAnalysis || showIntersections) && funcs[0]?.fn) {
                    const timeout = setTimeout(() => {
                        setAnalysisData(analyzeFunctionProperties(funcs[0].fn, view));
                    }, 200); 
                    return () => clearTimeout(timeout);
                }
            }, [funcs[0]?.fn, view, showAnalysis, showIntersections]);

            useEffect(() => {
                if (!containerRef.current) return;
                const obs = new ResizeObserver(e => {
                    if(e[0].contentRect.width>0) setDims({ w: e[0].contentRect.width, h: e[0].contentRect.height });
                });
                obs.observe(containerRef.current);
                return () => obs.disconnect();
            }, []);

            // --- INTERAZIONI MOUSE/TOUCH ---
            const handleStart = (clientX, clientY) => {
                if(!interactive) return;
                setDragging(true); setLastPos({ x: clientX, y: clientY });
            };

            const handleMove = (clientX, clientY) => {
                if (!containerRef.current) return;
                const r = containerRef.current.getBoundingClientRect();
                const relX = clientX - r.left; const relY = clientY - r.top;
                let graphX = mapRange(relX, 0, dims.w, view.xMin, view.xMax);
                const graphY = mapRange(relY, dims.h, 0, view.yMin, view.yMax);
                
                const snapRange = (view.xMax - view.xMin) / 100;
                if (Math.abs(graphX - Math.round(graphX)) < snapRange) graphX = Math.round(graphX);
                
                let curveY = null;
                if (funcs[0]?.fn) {
                    try { const y = funcs[0].fn(graphX); if (!isNaN(y) && isFinite(y)) curveY = y; } catch (e) {}
                }
                setCursor({ x: relX, y: relY, graphX, graphY, curveY });

                if(dragging) {
                    const dx = (clientX - lastPos.x) * (view.xMax - view.xMin) / dims.w;
                    const dy = (clientY - lastPos.y) * (view.yMax - view.yMin) / dims.h; 
                    setView(v => ({ xMin: v.xMin - dx, xMax: v.xMax - dx, yMin: v.yMin + dy, yMax: v.yMax + dy }));
                    setLastPos({x: clientX, y: clientY});
                }
            };

            const handleWheel = (e) => {
                if (!interactive || !containerRef.current) return;
                e.preventDefault(); 
                const r = containerRef.current.getBoundingClientRect();
                const mouseX = e.clientX - r.left;
                const mouseY = e.clientY - r.top;
                const graphMouseX = mapRange(mouseX, 0, dims.w, view.xMin, view.xMax);
                const graphMouseY = mapRange(mouseY, dims.h, 0, view.yMin, view.yMax);
                const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9; 
                const newWidth = (view.xMax - view.xMin) * zoomFactor;
                const newHeight = (view.yMax - view.yMin) * zoomFactor;
                const newXMin = graphMouseX - (graphMouseX - view.xMin) * zoomFactor;
                const newYMin = graphMouseY - (graphMouseY - view.yMin) * zoomFactor;
                setView({ xMin: newXMin, xMax: newXMin + newWidth, yMin: newYMin, yMax: newYMin + newHeight });
            };

            const toSvgX = useCallback(x => mapRange(x, view.xMin, view.xMax, 0, dims.w), [view, dims.w]);
            const toSvgY = useCallback(y => mapRange(y, view.yMin, view.yMax, dims.h, 0), [view, dims.h]);

            const handleSlider = (e) => {
                const val = parseFloat(e.target.value);
                setSliderX(val);
            };

            const paths = useMemo(() => funcs.map(f => {
                if(!f.fn || dims.w===0) return null;
                const step = (view.xMax - view.xMin) / (dims.w); 
                const samplingStep = step; 

                let d = '', pos='', neg='', fst=true, fP=true, fN=true, pY=null;
                for(let x=view.xMin; x<=view.xMax; x+=samplingStep) {
                    let y; try { y = f.fn(x); } catch { y=NaN; }
                    const isJump = pY!==null && Math.abs(y-pY) > (view.yMax-view.yMin)*0.8;
                    if (isNaN(y) || !isFinite(y) || isJump) { fst=true; fP=true; fN=true; pY=null; continue; }
                    const safeSy = Math.max(-5000, Math.min(5000, toSvgY(y)));
                    const sx = toSvgX(x);
                    
                    if(f.type==='sign') {
                        // Interpolazione per trovare lo zero e chiudere il gap
                        if (pY !== null && Math.sign(y) !== Math.sign(pY) && !isNaN(pY)) {
                            // y = mx + q approximation around zero
                            // fraction of step to reach zero: y_ratio = |pY| / (|pY| + |y|)
                            const ratio = Math.abs(pY) / (Math.abs(pY) + Math.abs(y));
                            const zeroX = x - step + ratio * step;
                            const zeroSx = toSvgX(zeroX);
                            const zeroSy = toSvgY(0);
                            
                            if (pY >= 0) { // Was positive, going negative
                                pos += ` L ${zeroSx} ${zeroSy}`;
                                neg += ` M ${zeroSx} ${zeroSy}`;
                            } else { // Was negative, going positive
                                neg += ` L ${zeroSx} ${zeroSy}`;
                                pos += ` M ${zeroSx} ${zeroSy}`;
                            }
                        }

                        if(y>=0) { 
                            pos += fP ? `M ${sx} ${safeSy}` : ` L ${sx} ${safeSy}`; 
                            fP=false; fN=true; 
                        } else { 
                            neg += fN ? `M ${sx} ${safeSy}` : ` L ${sx} ${safeSy}`; 
                            fN=false; fP=true; 
                        }
                    } else {
                        d += fst ? `M ${sx} ${safeSy}` : ` L ${sx} ${safeSy}`; fst=false;
                    }
                    pY=y;
                }
                return { d, pos, neg, ...f };
            }), [funcs, view, dims]);

            const symData = useMemo(() => {
                if (!funcs[0]?.symmetryMode || !funcs[0].fn) return null;
                const x1 = sliderX; 
                try { return { x1, y1: funcs[0].fn(x1), x2: -x1, y2: funcs[0].fn(-x1) }; } catch { return null; }
            }, [sliderX, funcs]);

            return (
                <div className="flex flex-col h-full w-full bg-surface dark:bg-darkgray rounded-2xl border border-slate-200 dark:border-slate-800 shadow-sm overflow-hidden relative">
                    <AnalysisPanel data={analysisData} visible={showAnalysis} currentFunctionStr={currentFunctionStr} />
                    
                    <div ref={containerRef} className="flex-1 w-full relative overflow-hidden cursor-crosshair touch-none select-none"
                        onMouseDown={e => handleStart(e.clientX, e.clientY)}
                        onMouseMove={e => handleMove(e.clientX, e.clientY)}
                        onMouseUp={() => setDragging(false)}
                        onMouseLeave={() => { setDragging(false); setCursor(null); }}
                        onWheel={handleWheel}
                        onTouchStart={e => handleStart(e.touches[0].clientX, e.touches[0].clientY)}
                        onTouchMove={e => handleMove(e.touches[0].clientX, e.touches[0].clientY)}
                        onTouchEnd={() => { setDragging(false); setCursor(null); }}
                    >
                        <svg width="100%" height="100%" viewBox={`0 0 ${dims.w} ${dims.h}`} preserveAspectRatio="none">
                            {showGrid && (() => {
                                const stepX = getNiceStep(view.xMax - view.xMin);
                                const stepY = getNiceStep(view.yMax - view.yMin);
                                const startX = Math.ceil(view.xMin / stepX) * stepX;
                                const startY = Math.ceil(view.yMin / stepY) * stepY;
                                const tx = []; for (let x = startX; x <= view.xMax; x += stepX) tx.push(x);
                                const ty = []; for (let y = startY; y <= view.yMax; y += stepY) ty.push(y);

                                return (
                                    <g className="text-[10px] fill-slate-400 dark:fill-slate-600 font-mono" pointerEvents="none">
                                        <line x1={0} y1={toSvgY(0)} x2={dims.w} y2={toSvgY(0)} className="stroke-slate-800 dark:stroke-slate-200 stroke-2" />
                                        <line x1={toSvgX(0)} y1={0} x2={toSvgX(0)} y2={dims.h} className="stroke-slate-800 dark:stroke-slate-200 stroke-2" />
                                        {tx.map(x => x!==0 && (<g key={`x${x}`}><line x1={toSvgX(x)} y1={0} x2={toSvgX(x)} y2={dims.h} className="stroke-slate-200 dark:stroke-slate-800 stroke-1"/><text x={toSvgX(x)+2} y={dims.h-5}>{parseFloat(x.toPrecision(4))}</text></g>))}
                                        {ty.map(y => y!==0 && (<g key={`y${y}`}><line x1={0} y1={toSvgY(y)} x2={dims.w} y2={toSvgY(y)} className="stroke-slate-200 dark:stroke-slate-800 stroke-1"/><text x={2} y={toSvgY(y)-2}>{parseFloat(y.toPrecision(4))}</text></g>))}
                                    </g>
                                );
                            })()}
                            
                            {/* DOMAIN HIGHLIGHTER CON TESCHI */}
                            {highlightDomain && funcs[0]?.fn && (() => {
                                const rects = []; 
                                const skulls = [];
                                let start = null; 
                                let pY = null;
                                const step = (view.xMax - view.xMin) / 400; 
                                
                                for(let x = view.xMin; x <= view.xMax; x += step) {
                                    let y; let valid = true; 
                                    try { y = funcs[0].fn(x); if(isNaN(y) || !isFinite(y)) valid=false; } catch { valid=false; }
                                    const isJump = valid && pY!==null && Math.abs(y-pY) > (view.yMax-view.yMin)*0.8;
                                    if(valid && !isJump) { if(start === null) start = x; } 
                                    else { 
                                        if(start !== null) { 
                                            rects.push({s: start, e: x}); 
                                            if(!valid || isJump) { skulls.push({x: x, type: isJump ? 'jump' : 'void'}); }
                                            start = null; 
                                        } 
                                    }
                                    pY = valid ? y : null;
                                }
                                if(start!==null) rects.push({s: start, e: view.xMax});
                                const uniqueSkulls = skulls.filter((s, i) => i===0 || Math.abs(s.x - skulls[i-1].x) > (view.xMax-view.xMin)/20);
                                return (
                                    <g>
                                        {rects.map((r, i) => (<line key={`d${i}`} x1={toSvgX(r.s)} y1={toSvgY(0)} x2={toSvgX(r.e)} y2={toSvgY(0)} className="stroke-green-500 dark:stroke-neon-green" strokeWidth="6" opacity="0.6" />))}
                                        {uniqueSkulls.map((s, i) => (<text key={`s${i}`} x={toSvgX(s.x)} y={toSvgY(0)} dy="0.3em" textAnchor="middle" fontSize="24" className="fill-white skull-shadow select-none">ðŸ’€</text>))}
                                    </g>
                                );
                            })()}

                            {/* ZERO INTERSECTIONS HIGHLIGHTER */}
                            {showIntersections && analysisData && analysisData.zeros.length > 0 && (
                                <g>
                                    {analysisData.zeros.map((z, i) => (
                                        <g key={`z${i}`}>
                                            <text x={toSvgX(z)} y={toSvgY(0)} dy="0.3em" textAnchor="middle" fontSize="20" className="fill-white skull-shadow select-none animate-pulse-subtle">âœ¨</text>
                                        </g>
                                    ))}
                                </g>
                            )}

                            {paths.map((p, i) => {
                                if(!p) return null;
                                if(p.type==='sign') return <g key={i}><path d={p.pos} fill="none" strokeWidth={3} className="stroke-neon-green neon-glow" /><path d={p.neg} fill="none" strokeWidth={3} className="stroke-neon-red neon-glow" /></g>
                                return <path key={i} d={p.d} fill="none" stroke={p.color} strokeWidth={p.width||3} strokeDasharray={p.dashed?"5,5":""} className={!p.color?"stroke-indigo-600 dark:stroke-neon-blue neon-glow":""} opacity={p.opacity||1} vectorEffect="non-scaling-stroke"/>;
                            })}
                            
                            {enableSlider && funcs[0]?.fn && !isNaN(funcs[0].fn(sliderX)) && (
                                <g>
                                    <circle cx={toSvgX(sliderX)} cy={toSvgY(funcs[0].fn(sliderX))} r="6" className="fill-white dark:fill-neon-yellow stroke-indigo-600 dark:stroke-white stroke-2 shadow-lg" />
                                    {showHorizontalTest && <line x1="0" y1={toSvgY(funcs[0].fn(sliderX))} x2={dims.w} y2={toSvgY(funcs[0].fn(sliderX))} className="stroke-amber-500 dark:stroke-neon-yellow" strokeWidth="2" strokeDasharray="4" />}
                                </g>
                            )}
                            {symData && (<g><line x1={toSvgX(symData.x1)} y1={toSvgY(symData.y1)} x2={toSvgX(symData.x2)} y2={toSvgY(symData.y2)} className="stroke-slate-400 stroke-1 stroke-dashed" /><circle cx={toSvgX(symData.x2)} cy={toSvgY(symData.y2)} r="4" className="fill-orange-500 dark:fill-neon-orange" /></g>)}
                            {enableCrosshair && cursor && cursor.curveY !== null && (
                                <g pointerEvents="none">
                                    <line x1={toSvgX(cursor.graphX)} y1={0} x2={toSvgX(cursor.graphX)} y2={dims.h} className="stroke-slate-400 dark:stroke-slate-600 stroke-1 dashed" />
                                    <circle cx={toSvgX(cursor.graphX)} cy={toSvgY(cursor.curveY)} r="5" className="fill-white dark:fill-black stroke-neon-blue stroke-2" />
                                    <g transform={`translate(${toSvgX(cursor.graphX)}, ${toSvgY(cursor.curveY) - 40})`}>
                                        <rect x="-50" y="-20" width="100" height="24" rx="4" className="fill-slate-900/90 dark:fill-black/90 stroke-slate-600" />
                                        <text x="0" y="-4" textAnchor="middle" fontSize="10" className="fill-white font-mono">({cursor.graphX.toFixed(2)}, {cursor.curveY.toFixed(2)})</text>
                                    </g>
                                </g>
                            )}
                        </svg>
                        <button className="absolute bottom-12 right-2 bg-surface dark:bg-darkgray p-2 rounded-lg shadow-lg border dark:border-slate-700 text-slate-500 hover:text-indigo-600 transition" onClick={() => setView({ xMin: -10, xMax: 10, yMin: -10, yMax: 10 })}><Icon name="maximize" size={16} /></button>
                    </div>
                    {enableSlider && (
                        <div className="p-2 bg-slate-100 dark:bg-black/40 border-t dark:border-slate-800 flex gap-2 text-xs font-mono font-bold text-slate-500 items-center shrink-0">
                            <span className="w-8 text-right">{view.xMin.toFixed(1)}</span>
                            <input type="range" min={view.xMin} max={view.xMax} step={(view.xMax-view.xMin)/500} value={sliderX} onChange={handleSlider} className="flex-1 accent-indigo-600 dark:accent-neon-blue" />
                            <span className="w-8">{view.xMax.toFixed(1)}</span>
                        </div>
                    )}
                </div>
            );
        };

        const WelcomeScreen = ({ onSelect }) => (
            <div className="fixed inset-0 z-50 bg-surface dark:bg-amoled flex flex-col items-center justify-center p-6 text-center animate-fadeIn space-y-8">
                <div>
                    <h1 className="text-4xl md:text-6xl font-black bg-clip-text text-transparent bg-gradient-to-r from-indigo-600 to-purple-600 dark:from-neon-blue dark:to-neon-purple mb-4">MatematicaLab</h1>
                    <p className="text-slate-500 dark:text-slate-400 font-mono text-sm">V16.2 // ANALISI AVANZATA + AI ðŸ¤–</p>
                </div>
                <div className="flex flex-col sm:flex-row gap-6 w-full max-w-xs sm:max-w-md">
                    <button onClick={()=>onSelect('light')} className="flex-1 p-6 rounded-2xl border-2 border-slate-200 hover:border-indigo-500 bg-background transition-all hover:-translate-y-1 group">
                        <Icon name="sun" size={32} className="mx-auto mb-3 text-orange-500 group-hover:scale-110 transition" />
                        <div className="font-bold text-slate-800">Classico</div>
                    </button>
                    <button onClick={()=>onSelect('dark')} className="flex-1 p-6 rounded-2xl border-2 border-slate-800 hover:border-neon-blue bg-darkgray transition-all hover:-translate-y-1 group">
                        <Icon name="zap" size={32} className="mx-auto mb-3 text-neon-blue group-hover:scale-110 transition" />
                        <div className="font-bold text-on-background">Neon</div>
                    </button>
                </div>
            </div>
        );

        const FreeLabPage = () => {
            const [ex, setEx] = useState("x^3 - 3*x");
            const [magicModalOpen, setMagicModalOpen] = useState(false);
            const [magicPrompt, setMagicPrompt] = useState("");
            const [magicLoading, setMagicLoading] = useState(false);

            const fn = useMemo(() => parseFunctionString(ex), [ex]);

            const handleMagicGenerate = async () => {
                if(!magicPrompt.trim()) return;
                setMagicLoading(true);
                const systemPrompt = `Sei un traduttore da linguaggio naturale a formule matematiche Javascript.
                L'utente descrive una funzione. Tu restituisci SOLO la formula matematica in formato testo compatibile con Javascript/Math.js.
                Esempi:
                User: "Una parabola" -> "x^2"
                User: "Un seno smorzato" -> "sin(x)/x"
                User: "Esponenziale che cresce" -> "exp(x)"
                NON aggiungere altro testo. Solo la formula.`;
                
                const result = await runGemini(magicPrompt, systemPrompt);
                const cleanResult = result.replace(/`/g, '').replace(/javascript/g, '').trim();
                
                if(cleanResult && cleanResult.length < 50) { 
                    setEx(cleanResult);
                    setMagicModalOpen(false);
                } else {
                    alert("Non sono riuscito a generare una funzione valida. Riprova.");
                }
                setMagicLoading(false);
                setMagicPrompt("");
            };

            return (
                <div className="flex flex-col h-full gap-4 relative">
                    <div className="bg-surface dark:bg-darkgray p-3 md:p-4 rounded-2xl border border-slate-200 dark:border-slate-800 shrink-0 shadow-sm flex flex-col gap-3">
                        <MathInput 
                            value={ex} 
                            onChange={e=>setEx(e.target.value)} 
                            label="f(x)" 
                            onMagicClick={() => setMagicModalOpen(true)}
                        />
                        <div className="flex gap-2 overflow-x-auto hide-scrollbar w-full pb-1">
                            {['sin(x)','exp(x)','1/x','abs(x)', 'x^2', 'sqrt(x)'].map(f=><button key={f} onClick={()=>setEx(f)} className="px-3 py-1.5 rounded-lg bg-slate-100 dark:bg-slate-800 text-xs font-mono font-bold hover:bg-indigo-100 dark:hover:bg-slate-700 transition whitespace-nowrap">{f}</button>)}
                        </div>
                    </div>
                    <div className="flex-1 min-h-0 relative"><GraphEngine funcs={[{fn}]} showAnalysis={true} currentFunctionStr={ex} /></div>

                    {/* MAGIC MODAL */}
                    {magicModalOpen && (
                        <div className="absolute inset-0 z-50 flex items-center justify-center p-4 bg-black/20 backdrop-blur-sm animate-fadeIn">
                            <div className="bg-surface dark:bg-darkgray border border-slate-200 dark:border-slate-700 p-6 rounded-2xl shadow-2xl w-full max-w-sm">
                                <h3 className="text-xl font-bold mb-2 flex items-center gap-2 dark:text-white">
                                    <Icon name="sparkles" className="text-indigo-500 dark:text-neon-blue"/> Genera con AI
                                </h3>
                                <p className="text-sm text-slate-500 mb-4">Descrivi a parole la funzione che vuoi vedere.</p>
                                <textarea 
                                    value={magicPrompt}
                                    onChange={e => setMagicPrompt(e.target.value)}
                                    placeholder="Es: Una funzione che oscilla e poi scende..."
                                    className="w-full bg-slate-100 dark:bg-black/30 border border-slate-200 dark:border-slate-700 rounded-xl p-3 text-sm mb-4 min-h-[100px] outline-none focus:border-indigo-500 transition-colors dark:text-white"
                                />
                                <div className="flex gap-2 justify-end">
                                    <button onClick={() => setMagicModalOpen(false)} className="px-4 py-2 rounded-lg text-sm font-bold text-slate-500 hover:bg-slate-100 dark:hover:bg-white/5 transition-colors">Annulla</button>
                                    <button 
                                        onClick={handleMagicGenerate} 
                                        disabled={magicLoading}
                                        className="px-4 py-2 rounded-lg text-sm font-bold bg-indigo-600 hover:bg-indigo-700 text-on-background shadow-lg shadow-indigo-500/30 flex items-center gap-2 disabled:opacity-50"
                                    >
                                        {magicLoading ? <Icon name="loader-2" className="animate-spin" size={16}/> : <Icon name="wand-2" size={16}/>}
                                        {magicLoading ? 'Genero...' : 'Genera'}
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const SymPage = () => {
            const [m, setM] = useState('pari');
            const [ex, setEx] = useState('x^2');
            const fn = useMemo(()=>parseFunctionString(ex),[ex]);
            return (
                <div className="flex flex-col lg:flex-row h-full gap-4">
                    <div className="lg:w-72 flex flex-col gap-4 shrink-0 overflow-y-auto">
                        <div className="bg-surface dark:bg-darkgray p-4 rounded-2xl border dark:border-slate-800 shadow-sm">
                            <h3 className="font-bold text-sm mb-3 dark:text-white uppercase tracking-wider">Simmetria</h3>
                            <div className="flex bg-slate-100 dark:bg-slate-900 p-1 rounded-lg mb-4">
                                {['pari','dispari'].map(k=><button key={k} onClick={()=>{setM(k); setEx(k==='pari'?'x^2':'x^3')}} className={`flex-1 py-1.5 rounded-md font-bold text-xs capitalize transition ${m===k?'bg-white dark:bg-slate-700 shadow text-indigo-600 dark:text-neon-blue':'text-slate-500'}`}>{k}</button>)}
                            </div>
                            <div className="p-3 bg-indigo-50 dark:bg-indigo-900/20 rounded-lg border border-indigo-100 dark:border-indigo-800/50 mb-4">
                                <p className="text-xs font-mono text-indigo-700 dark:text-indigo-300 text-center">
                                    {m==='pari' ? 'f(x) = f(-x)' : 'f(-x) = -f(x)'}
                                </p>
                            </div>
                            <MathInput value={ex} onChange={e=>setEx(e.target.value)} label="f(x)" />
                        </div>
                    </div>
                    <div className="flex-1 min-h-0 relative"><GraphEngine funcs={[{fn, symmetryMode: m}]} /></div>
                </div>
            );
        };

        const DomPage = () => {
            const [ex, setEx] = useState('1/x'); 
            const fn = useMemo(()=>parseFunctionString(ex),[ex]);
            return (
                <div className="flex flex-col h-full gap-4">
                    <div className="bg-surface dark:bg-darkgray p-4 rounded-2xl border dark:border-slate-800 shrink-0 shadow-sm flex flex-col md:flex-row items-center gap-4">
                        <div className="flex-1 w-full"><MathInput value={ex} onChange={e=>setEx(e.target.value)} label="f(x)" /></div>
                        <div className="text-xs text-slate-500 bg-slate-100 dark:bg-slate-800 px-3 py-2 rounded-lg border dark:border-slate-700 whitespace-nowrap">
                            <strong>DOMINIO:</strong> Linee verdi = Esiste. ðŸ’€ = Punti critici.
                        </div>
                    </div>
                    <div className="flex-1 min-h-0 relative"><GraphEngine funcs={[{fn}]} highlightDomain={true} showAnalysis={true} currentFunctionStr={ex} /></div>
                </div>
            );
        };

        const SignPage = () => {
            const [ex, setEx] = useState('x^2 - 4'); 
            const fn = useMemo(()=>parseFunctionString(ex),[ex]);
            return (
                <div className="flex flex-col h-full gap-4">
                    <div className="bg-surface dark:bg-darkgray p-4 rounded-2xl border dark:border-slate-800 shrink-0 shadow-sm flex flex-col md:flex-row items-center gap-4">
                        <div className="flex-1 w-full"><MathInput value={ex} onChange={e=>setEx(e.target.value)} label="f(x)" /></div>
                        <div className="text-xs text-slate-500 bg-slate-100 dark:bg-slate-800 px-3 py-2 rounded-lg border dark:border-slate-700 whitespace-nowrap">
                            <span className="text-neon-green font-bold">POS</span> / <span className="text-neon-red font-bold">NEG</span>. âœ¨ = Zeri.
                        </div>
                    </div>
                    <div className="flex-1 min-h-0 relative"><GraphEngine funcs={[{fn, type: 'sign'}]} showIntersections={true} showAnalysis={true} currentFunctionStr={ex} /></div>
                </div>
            );
        };

        const ClassPage = () => {
            const [m, setM] = useState('inj');
            const presets = { inj:{e:'x^3+x',t:'Iniettiva', d:'Ogni y ha al massimo una x.'}, surj:{e:'x^3-x',t:'Suriettiva', d:'Il codominio copre tutto R.'}, bij:{e:'x+2',t:'Biiettiva', d:'Sia iniettiva che suriettiva.'} };
            const fn = useMemo(()=>parseFunctionString(presets[m].e),[m]);
            return (
                <div className="flex flex-col lg:flex-row h-full gap-4">
                    <div className="lg:w-64 flex lg:flex-col gap-2 shrink-0 overflow-x-auto lg:overflow-visible pb-1">
                        {Object.entries(presets).map(([k,v])=>(
                            <button key={k} onClick={()=>setM(k)} className={`p-3 rounded-xl border text-left transition-all min-w-[140px] ${m===k?'bg-indigo-600 border-indigo-600 text-on-background shadow-md':'bg-white dark:bg-darkgray dark:border-slate-700 hover:border-indigo-400'}`}>
                                <div className="font-bold text-sm mb-1">{v.t}</div>
                                <div className={`text-[10px] ${m===k?'text-indigo-200':'text-slate-500'}`}>{v.d}</div>
                            </button>
                        ))}
                    </div>
                    <div className="flex-1 min-h-0 relative rounded-2xl border dark:border-slate-800 overflow-hidden bg-surface dark:bg-amoled">
                        <GraphEngine funcs={[{fn, color:'#0ea5e9'}]} showHorizontalTest={true} />
                        <div className="absolute top-4 right-4 bg-black/60 text-on-background px-3 py-1 rounded-full text-xs backdrop-blur-md pointer-events-none">Test Orizzontale</div>
                    </div>
                </div>
            );
        };

        const CompPage = () => {
            const [o, setO] = useState('sin(x)');
            const [i, setI] = useState('x^2');
            const fo = useMemo(()=>parseFunctionString(o),[o]);
            const fi = useMemo(()=>parseFunctionString(i),[i]);
            const fc = useCallback(x=>{try{return fo(fi(x))}catch{return NaN}},[fo,fi]);
            
            return (
                <div className="flex flex-col h-full gap-4">
                    <div className="bg-surface dark:bg-darkgray p-4 rounded-2xl border dark:border-slate-800 flex flex-col md:flex-row justify-center items-center gap-4 shadow-sm shrink-0">
                        <div className="w-full md:w-1/3"><MathInput value={i} onChange={e=>setI(e.target.value)} label="g(x)" placeholder="Interna" /></div>
                        <Icon name="arrow-right" className="text-slate-400 rotate-90 md:rotate-0"/>
                        <div className="w-full md:w-1/3"><MathInput value={o} onChange={e=>setO(e.target.value)} label="f(...)" placeholder="Esterna" /></div>
                    </div>
                    <div className="flex-1 min-h-0 relative rounded-2xl border dark:border-slate-800 overflow-hidden bg-surface dark:bg-amoled">
                        <GraphEngine funcs={[
                            {fn:fc, width:4, color: '#00f3ff'}, 
                            {fn:fi, color:'#94a3b8', width:2, dashed:true, opacity:0.3},
                            {fn:fo, color:'#94a3b8', width:2, dashed:true, opacity:0.3}
                        ]} 
                        overlayText={`h(x) = f(g(x))`}/>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [page, setPage] = useState('lab');
            const [menuOpen, setMenuOpen] = useState(false);
            const [theme, setTheme] = useState(null);

            useEffect(() => {
                if(theme==='dark') document.documentElement.classList.add('dark');
                else document.documentElement.classList.remove('dark');
            }, [theme]);

            if(!theme) return <WelcomeScreen onSelect={setTheme} />;

            const MENU = [
                {id: 'lab', label: 'Lab Libero', icon: 'flask-conical'},
                {id: 'sym', label: 'Simmetrie', icon: 'maximize'},
                {id: 'an', label: 'Dominio', icon: 'activity'},
                {id: 'sign', label: 'Segno', icon: 'binary'},
                {id: 'class', label: 'Classificazione', icon: 'git-fork'},
                {id: 'comp', label: 'Composizione', icon: 'refresh-cw'}
            ];

            return (
                <div className="flex h-full flex-col lg:flex-row bg-background dark:bg-darkgray transition-colors duration-500">
                    <aside className={`fixed lg:relative inset-y-0 left-0 z-50 w-64 shrink-0 bg-surface dark:bg-darkgray border-r border-slate-200 dark:border-slate-800 transform transition-transform duration-300 ${menuOpen ? 'translate-x-0' : '-translate-x-full'} lg:translate-x-0 shadow-2xl lg:shadow-none flex flex-col`}>
                        <div className="p-6 border-b border-slate-100 dark:border-slate-800 flex justify-between items-center">
                            <h1 className="text-xl font-black text-slate-900 dark:text-white">Matematica<span className="text-indigo-600 dark:text-neon-blue">Lab</span></h1>
                            <button onClick={()=>setMenuOpen(false)} className="lg:hidden text-slate-500"><Icon name="x" /></button>
                        </div>
                        <nav className="flex-1 p-4 space-y-1 overflow-y-auto">
                            {MENU.map(i=>(
                                <button key={i.id} onClick={()=>{setPage(i.id);setMenuOpen(false)}} 
                                    className={`w-full flex items-center gap-3 px-4 py-3 rounded-xl font-medium text-sm transition-all ${page===i.id?'bg-indigo-50 dark:bg-slate-800 text-indigo-700 dark:text-neon-blue shadow-sm':'text-slate-500 dark:text-slate-400 hover:bg-slate-50 dark:hover:bg-slate-800'}`}>
                                    <Icon name={i.icon} size={18} /> {i.label}
                                </button>
                            ))}
                        </nav>
                        <div className="p-4 border-t border-slate-100 dark:border-slate-800 flex justify-between items-center">
                             <a href="../index.html" className="text-xs font-bold text-slate-400 hover:text-indigo-500 flex items-center gap-2">
                                <Icon name="arrow-left" size={14}/> ESCI
                            </a>
                            <button onClick={()=>setTheme(theme==='light'?'dark':'light')} className="p-2 rounded-lg hover:bg-slate-100 dark:hover:bg-slate-800 transition">
                                <Icon name={theme==='light'?'moon':'sun'} size={18} className="text-slate-400"/>
                            </button>
                        </div>
                    </aside>

                    <main className="flex-1 flex flex-col overflow-hidden relative w-full h-full min-w-0">
                        <div className="lg:hidden h-14 bg-surface dark:bg-darkgray border-b border-slate-200 dark:border-slate-800 flex items-center justify-between px-4 z-10 shrink-0">
                            <span className="font-bold dark:text-white flex items-center gap-2 text-sm"><Icon name={MENU.find(m=>m.id===page).icon} size={18}/> {MENU.find(m=>m.id===page).label}</span>
                            <button onClick={()=>setMenuOpen(true)} className="p-2 bg-slate-100 dark:bg-slate-800 rounded-lg"><Icon name="menu" className="dark:text-white"/></button>
                        </div>
                        
                        <div className="flex-1 bg-background dark:bg-black/50 overflow-hidden relative p-2 md:p-4">
                            {page==='lab' && <FreeLabPage />}
                            {page==='sym' && <SymPage />}
                            {page==='an' && <DomPage />}
                            {page==='sign' && <SignPage />}
                            {page==='class' && <ClassPage />}
                            {page==='comp' && <CompPage />}
                        </div>
                    </main>
                    
                    {menuOpen && <div className="fixed inset-0 bg-black/50 z-40 lg:hidden backdrop-blur-sm" onClick={()=>setMenuOpen(false)}></div>}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>