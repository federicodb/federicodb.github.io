<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    
    <!-- 1. META DATI PER CATALOGAZIONE -->
    <title>Caccia all'Errore: Operazioni in Z</title>
    <meta name="description" content="Missione di addestramento sui Numeri Interi (Z) e le Potenze. Trova le corrispondenze corrette ed evita le trappole degli errori comuni di calcolo.">
    <meta name="keywords" content="Matematica, Aritmetica, Numeri Interi, Z, Potenze, Errori Comuni, 1EL, Mat:Calcolo, Mat:ProblemSolving, Gamification, EU:STEM">
    <meta name="date" content="2025-10-20">

    <!-- 2. FIX MOBILE -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">

    <title>MathMatch 4.1 - Smart Scaffolding</title>

    <!-- Shared Orfini Design System -->
    <link rel="stylesheet" href="../assets/style/orfini-shared.css">
    <script src="../assets/js/orfini-shared.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Configurazione Tailwind con Colori Semantici -->
    <script>
        tailwind.config = {
            darkMode: ['class', '[data-theme="dark"]'],
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        math: ['Noto Serif', 'serif'],
                    },
                    colors: {
                        background: 'var(--md-sys-color-background)',
                        'on-background': 'var(--md-sys-color-on-background)',
                        surface: 'var(--md-sys-color-surface)',
                        'surface-container': 'var(--md-sys-color-surface-container)',
                        'on-surface-variant': 'var(--md-sys-color-on-surface-variant)',
                        'outline-variant': 'var(--md-sys-color-outline-variant)',
                        primary: 'var(--md-sys-color-primary)',
                        'on-primary': 'var(--md-sys-color-on-primary)',
                    },
                    animation: {
                        'bounce-short': 'bounce 0.5s ease-in-out 1',
                        'pulse-fast': 'pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>

    <!-- KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&family=Noto+Serif:wght@700&display=swap');

        /* 3. CSS FULLSCREEN ROBUSTO */
        html, body {
            margin: 0; padding: 0;
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Blocca scroll elastico */
            width: 100vw;
            height: 100dvh; /* Altezza dinamica reale */
            position: fixed; /* Inchioda la pagina */
            touch-action: manipulation;
            -webkit-user-select: none; user-select: none;
        }

        /* --- 3D ENGINE --- */
        .perspective-1000 {
            perspective: 1000px;
        }

        .flipper {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.4, 0.0, 0.2, 1);
            will-change: transform;
            border-radius: 0.75rem;
        }

        .flipper.flipped {
            transform: rotateY(180deg);
        }

        .face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            border-radius: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            top: 0;
            left: 0;
        }

        .face-front {
            transform: rotateY(0deg);
            z-index: 2;
        }

        .face-back {
            transform: rotateY(180deg);
        }

        /* Tipografia Matematica */
        .font-math {
            font-family: 'Noto Serif', serif;
        }

        /* Scrollbar */
        .scroller::-webkit-scrollbar {
            width: 6px;
        }

        .scroller::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        .dark .scroller::-webkit-scrollbar-thumb {
            background: #475569;
        }

        #confetti-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>

<body>
    <div id="root" class="h-full w-full"></div>

    <script type="text/babel">
        const React = window.React;
        const ReactDOM = window.ReactDOM;
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // --- AUDIO ENGINE ---
        const AudioEngine = {
            ctx: null,
            init: function () {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },
            playTone: function (freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            playFlip: function () { this.playTone(400, 'sine', 0.1, 0.05); },
            playMatch: function () {
                this.playTone(523.25, 'triangle', 0.2, 0.1);
                setTimeout(() => this.playTone(659.25, 'triangle', 0.2, 0.1), 100);
                setTimeout(() => this.playTone(783.99, 'triangle', 0.4, 0.1), 200);
            },
            playError: function () {
                this.playTone(150, 'sawtooth', 0.3, 0.05);
                setTimeout(() => this.playTone(100, 'sawtooth', 0.3, 0.05), 100);
            },
            playWin: function () {
                const notes = [523.25, 659.25, 783.99, 1046.50];
                notes.forEach((n, i) => setTimeout(() => this.playTone(n, 'square', 0.4, 0.05), i * 100));
            }
        };

        // --- CONFIGURAZIONE ---
        const RUSH_MEM_TIME = 30;
        const RUSH_PLAY_TIME = 45;

        const AVATARS = ['üë®‚ÄçüöÄ', 'üë©‚Äçüî¨', 'ü•∑', 'üßô‚Äç‚ôÇÔ∏è', 'üßõ‚Äç‚ôÄÔ∏è', 'üßú‚Äç‚ôÇÔ∏è', 'üßö‚Äç‚ôÄÔ∏è', 'üßû‚Äç‚ôÇÔ∏è', 'ü¶∏‚Äç‚ôÄÔ∏è', 'ü¶π‚Äç‚ôÇÔ∏è', 'üïµÔ∏è‚Äç‚ôÄÔ∏è', 'üßë‚Äçüé®', 'ü¶ä', 'ü¶â'];

        const EMOJI_POOL = [
            'üöÄ', 'üíé', 'üå∂Ô∏è', 'üçÑ', 'üé±', 'üé∏', 'üåµ', 'üî•', '‚ö°', 'üåà', 'ü™ê', 'üß©',
            'üé≤', 'üéØ', 'üé®', 'üé≠', 'üé™', 'üé°', 'üé¢', 'üéÉ', 'üéÑ', 'üéà', 'üéÅ', 'üèÜ',
            'ü•á', '‚öΩ', 'üèÄ', 'üéæ', 'üç©', 'üçï', 'üçü', 'üçî', 'ü¶Ñ', 'ü§ñ', 'üëæ', 'üëª'
        ];

        // Colori vividi per il testo
        const PAIR_COLORS = [
            'bg-rose-50 text-rose-950 border-rose-300',
            'bg-orange-50 text-orange-950 border-orange-300',
            'bg-amber-50 text-amber-950 border-amber-300',
            'bg-emerald-50 text-emerald-950 border-emerald-300',
            'bg-cyan-50 text-cyan-950 border-cyan-300',
            'bg-blue-50 text-blue-950 border-blue-300',
            'bg-violet-50 text-violet-950 border-violet-300',
            'bg-fuchsia-50 text-fuchsia-950 border-fuchsia-300',
        ];

        const LEVELS = [
            { id: 0, label: "Training", desc: "6 Carte", pairs: 3, points: 1000 },
            { id: 1, label: "Base", desc: "12 Carte", pairs: 6, points: 2000 },
            { id: 2, label: "Intermedio", desc: "16 Carte", pairs: 8, points: 3000 },
            { id: 3, label: "Avanzato", desc: "20 Carte", pairs: 10, points: 5000 }
        ];

        const GENERATORS_DEF = {
            pemdas: { label: "PEMDAS", active: true, desc: "\\text{Es: } 2 + 3 \\cdot 4 = 14" },
            trap: { label: "Trappole", active: true, desc: "\\text{Es: } 5 : 0 \\to \\text{Impossibile}" },
            integers: { label: "Interi Relativi", active: true, desc: "\\text{Es: } -5 - 3 = -8" },
            powers_prop: { label: "Propriet√† Potenze", active: true, desc: "\\text{Es: } 2^3 \\cdot 2^2 = 2^5" },
            exp_zero: { label: "Esponente Nullo", active: true, desc: "\\text{Es: } 125^0 = 1" },
            exp_neg: { label: "Esponente Negativo", active: true, desc: "\\text{Es: } 2^{-3} = 1/8" },
            opp_sum: { label: "Numeri Opposti", active: true, desc: "\\text{Es: } 5 + (-5) = 0" },
            inverse_prod: { label: "Numeri Inversi", active: true, desc: "\\text{Es: } 5 \\cdot \\frac{1}{5} = 1" },
            square5: { label: "Quadrati (Fine 5)", active: false, desc: "\\text{Es: } 35^2 = 1225" },
            square50: { label: "Quadrati (Vicino 50)", active: false, desc: "\\text{Es: } 48^2, 52^2" },
            square100: { label: "Quadrati (Vicino 100)", active: false, desc: "\\text{Es: } 98^2, 102^2" },
            mcd_mcm: { label: "M.C.D. e m.c.m.", active: false, desc: "\\text{Teoria dei numeri}" }
        };

        const EXPLANATIONS = {
            "pemdas": "Attenzione all'ordine! (X e :) prima di (+ e -)",
            "trap": "Operazione Impossibile o Non Definita",
            "integers": "Calcolo algebrico con numeri relativi",
            "powers_prop": "Propriet√† delle potenze (stessa base)",
            "exp_zero": "Qualsiasi numero (‚â†0) elevato a 0 vale 1",
            "exp_neg": "L'esponente negativo inverte la base",
            "opp_sum": "La somma di due numeri opposti √® 0",
            "inverse_prod": "Il prodotto di due inversi √® 1",
            "square5": "Regola del 5: n5¬≤ ‚Üí n(n+1)...25",
            "square50": "Vicino a 50: (50¬±d)¬≤ ‚Üí (25¬±d)...d¬≤",
            "square100": "Vicino a 100: (100¬±d)¬≤ ‚Üí (100¬±2d)...d¬≤",
            "mcd_mcm": "Teoria dei Numeri (M.C.D. / m.c.m.)",
        };

        const getRandomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

        // --- LOGICA MATEMATICA (Mantenuta identica alla 3.0/3.3) ---
        const generateMathItem = (type) => {
            switch (type) {
                case 'pemdas':
                    const pSub = getRandomInt(0, 5);
                    if (pSub === 0) { const a = getRandomInt(2, 6), b = getRandomInt(2, 5), c = getRandomInt(2, 4); return { poly: `${a} + ${b} \\cdot ${c}`, fact: `${a + b * c}`, type: "pemdas" }; }
                    else if (pSub === 1) { const c = getRandomInt(2, 4), b = c * getRandomInt(2, 5), a = getRandomInt(2, 10); return { poly: `${a} + ${b} : ${c}`, fact: `${a + b / c}`, type: "pemdas" }; }
                    else if (pSub === 2) { const a = getRandomInt(10, 20), b = getRandomInt(2, 5), c = getRandomInt(2, 4); return { poly: `${a} - ${b} + ${c}`, fact: `${a - b + c}`, type: "pemdas" }; }
                    else if (pSub === 3) { const b = getRandomInt(2, 4), a = b * getRandomInt(2, 4) * getRandomInt(2, 3), c = getRandomInt(2, 3); return { poly: `${a} : ${b} \\cdot ${c}`, fact: `${(a / b) * c}`, type: "pemdas" }; }
                    else if (pSub === 4) { const a = getRandomInt(2, 5), b = getRandomInt(2, 5), c = getRandomInt(2, 4); return { poly: `(${a} + ${b}) \\cdot ${c}`, fact: `${(a + b) * c}`, type: "pemdas" }; }
                    else { const b = getRandomInt(2, 5); return { poly: `-${b}^2`, fact: `${-1 * b * b}`, type: "pemdas" }; }
                case 'trap':
                    return Math.random() > 0.5 ? { poly: `${getRandomInt(1, 9)} : 0`, fact: `\\text{Impossibile}`, type: "trap" } : { poly: `\\sqrt{-${getRandomInt(2, 9) ** 2}}`, fact: `\\text{Non Reale}`, type: "trap" };
                case 'integers':
                    const a = getRandomInt(2, 12), b = getRandomInt(2, 12), s1 = Math.random() > 0.5 ? -1 : 1, s2 = Math.random() > 0.5 ? -1 : 1;
                    const valA = a * s1, valB = b * s2, termB = valB > 0 ? `+ ${valB}` : `- ${Math.abs(valB)}`;
                    return { poly: `${valA} ${termB}`, fact: `${valA + valB}`, type: "integers" };
                case 'powers_prop':
                    const ppType = getRandomInt(0, 2), base = getRandomInt(2, 5);
                    if (ppType === 0) { const e1 = getRandomInt(2, 4), e2 = getRandomInt(2, 4); return { poly: `${base}^${e1} \\cdot ${base}^${e2}`, fact: `${base}^${e1 + e2}`, type: "powers_prop" }; }
                    else if (ppType === 1) { const e2 = getRandomInt(2, 3), e1 = e2 + getRandomInt(1, 3); return { poly: `${base}^${e1} : ${base}^${e2}`, fact: `${base}^${e1 - e2}`, type: "powers_prop" }; }
                    else { const e1 = getRandomInt(2, 3), e2 = getRandomInt(2, 3); return { poly: `(${base}^${e1})^${e2}`, fact: `${base}^${e1 * e2}`, type: "powers_prop" }; }
                case 'exp_zero': return { poly: `${getRandomInt(2, 99)}^0`, fact: `1`, type: "exp_zero" };
                case 'exp_neg': { const nBase = getRandomInt(2, 4), nExp = getRandomInt(1, 3); return { poly: `${nBase}^{-${nExp}}`, fact: `\\frac{1}{${Math.pow(nBase, nExp)}}`, type: "exp_neg" }; }
                case 'opp_sum': { const oNum = getRandomInt(2, 20); return { poly: `${oNum} + (-${oNum})`, fact: `0`, type: "opp_sum" }; }
                case 'inverse_prod': { const iNum = getRandomInt(2, 9); return { poly: `${iNum} \\cdot \\frac{1}{${iNum}}`, fact: `1`, type: "inverse_prod" }; }
                case 'square5': { const n = getRandomInt(1, 9); return { poly: `${n}5^2`, fact: `${(n * (n + 1)) * 100 + 25}`, type: "square5" }; }
                case 'square50': { const d = getRandomInt(1, 4), s = Math.random() > 0.5 ? 1 : -1, num = 50 + d * s; return { poly: `${num}^2`, fact: `${num * num}`, type: "square50" }; }
                case 'square100': { const d = getRandomInt(1, 4), s = Math.random() > 0.5 ? 1 : -1, num = 100 + d * s; return { poly: `${num}^2`, fact: `${num * num}`, type: "square100" }; }
                case 'mcd_mcm':
                    if (Math.random() > 0.5) { const k = getRandomInt(2, 6), a = k * getRandomInt(2, 3), b = k * getRandomInt(4, 5), gcd = (x, y) => !y ? x : gcd(y, x % y); return { poly: `\\text{M.C.D.}(${a}, ${b})`, fact: `${gcd(a, b)}`, type: "mcd_mcm" }; }
                    else { const a = getRandomInt(2, 5), b = getRandomInt(2, 5), gcd = (x, y) => !y ? x : gcd(y, x % y); return { poly: `\\text{m.c.m.}(${a}, ${b})`, fact: `${(a * b) / gcd(a, b)}`, type: "mcd_mcm" }; }
                default: return { poly: "1+1", fact: "2", type: "error" };
            }
        };

        const generateCards = (levelId, activeGenerators) => {
            const levelConfig = LEVELS.find(l => l.id === levelId);
            const pairsCount = levelConfig.pairs;
            const pairs = [];
            const usedResults = new Set();

            const availableTypes = Object.keys(activeGenerators).filter(k => activeGenerators[k].active);
            if (availableTypes.length === 0) availableTypes.push('pemdas');

            let typePool = [];
            while (typePool.length < pairsCount) typePool = [...typePool, ...availableTypes];
            typePool = typePool.slice(0, pairsCount).sort(() => Math.random() - 0.5);

            // Gestione Trappola Unica
            if (activeGenerators['trap']?.active) {
                const idx = typePool.findIndex(t => t !== 'trap');
                if (idx >= 0) typePool[idx] = 'trap';
                let trapCount = 0;
                typePool = typePool.map(t => {
                    if (t === 'trap') return ++trapCount > 1 ? availableTypes[0] : t;
                    return t;
                });
            }

            for (let i = 0; i < pairsCount; i++) {
                let success = false, subAttempts = 0;
                while (!success && subAttempts < 100) {
                    subAttempts++;
                    const item = generateMathItem(typePool[i]);
                    let isUnique = false;
                    if (item.type === 'trap') {
                        if (!usedResults.has('TRAP')) { usedResults.add('TRAP'); isUnique = true; }
                    } else {
                        if (!usedResults.has(item.fact)) { usedResults.add(item.fact); isUnique = true; }
                    }
                    if (isUnique) { pairs.push(item); success = true; }
                }
                if (!success) pairs.push(generateMathItem('integers'));
            }

            const deck = [];
            const shuffledEmojis = [...EMOJI_POOL].sort(() => Math.random() - 0.5);

            pairs.forEach((p, i) => {
                const color = PAIR_COLORS[i % PAIR_COLORS.length];
                deck.push({ id: `p${i}a`, pairId: i, content: p.poly, cardType: 'question', emoji: shuffledEmojis[i * 2], color, ...p });
                deck.push({ id: `p${i}b`, pairId: i, content: p.fact, cardType: 'answer', emoji: shuffledEmojis[i * 2 + 1], color, ...p });
            });
            return deck.sort(() => Math.random() - 0.5).map(c => ({ ...c, isFlipped: false, isMatched: false, seen: false }));
        };

        const Icon = ({ d, size = 20, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d={d} /></svg>
        );

        const Icons = {
            Trophy: (p) => <Icon d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6 M18 9h1.5a2.5 2.5 0 0 0 0-5H18 M4 22h16 M10 14.66V17 M14 14.66V17 M12 2v10 M12 17a5 5 0 0 0-5 4 M12 17a5 5 0 0 1 5 4" {...p} />,
            Play: (p) => <Icon d="M5 3l14 9-14 9V3z" {...p} />,
            Timer: (p) => <Icon d="M10 2h4 M12 14l3-3 M12 14v-4 M12 22a8 8 0 1 0 0-16 8 8 0 0 0 0 16z" {...p} />,
            Settings: (p) => <Icon d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" {...p} />,
            Check: (p) => <Icon d="M22 11.08V12a10 10 0 1 1-5.93-9.14 M22 4 12 14.01 9 11.01" {...p} />,
            SoundOn: (p) => <Icon d="M11 5L6 9H2v6h4l5 4V5z M19.07 4.93a10 10 0 0 1 0 14.14 M15.54 8.46a5 5 0 0 1 0 7.07" {...p} />,
            SoundOff: (p) => <Icon d="M11 5L6 9H2v6h4l5 4V5z M23 9l-6 6 M17 9l6 6" {...p} />,
            Sun: (p) => <Icon d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" {...p} />,
            Moon: (p) => <Icon d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" {...p} />,
            Users: (p) => <Icon d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2 M9 7a4 4 0 1 0 0-8 4 4 0 0 0 0 8 M23 21v-2a4 4 0 0 0-3-3.87 M16 3.13a4 4 0 0 1 0 7.75" {...p} />,
            User: (p) => <Icon d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2 M12 7a4 4 0 1 0 0-8 4 4 0 0 0 0 8" {...p} />,
            Ghost: (p) => <Icon d="M9 22l1-4h4l1 4 M4 22h16 M12 2a8 8 0 0 0-8 8v12h16V10a8 8 0 0 0-8-8z M10 10h.01 M14 10h.01" {...p} />
        };

        const MathText = ({ txt, className = "", inline = false }) => {
            const html = useMemo(() => {
                try {
                    return window.katex ? window.katex.renderToString(txt, { throwOnError: false, displayMode: !inline }) : txt;
                } catch (e) { return txt; }
            }, [txt, inline]);
            return <div className={`font-math select-none pointer-events-none ${className} ${inline ? 'inline-block' : ''}`} dangerouslySetInnerHTML={{ __html: html }} />;
        };

        const Confetti = ({ active }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                if (!active) return;
                const ctx = canvasRef.current.getContext('2d');
                let particles = [];
                const resize = () => { canvasRef.current.width = window.innerWidth; canvasRef.current.height = window.innerHeight; };
                window.addEventListener('resize', resize); resize();
                for (let i = 0; i < 150; i++) particles.push({ x: Math.random() * window.innerWidth, y: Math.random() * window.innerHeight - window.innerHeight, vx: Math.random() * 4 - 2, vy: Math.random() * 5 + 2, color: ['#f43f5e', '#f59e0b', '#10b981', '#3b82f6', '#8b5cf6'][Math.floor(Math.random() * 5)], size: Math.random() * 8 + 4 });
                const loop = () => {
                    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
                    particles.forEach(p => { p.y += p.vy; p.x += p.vx; if (p.y > window.innerHeight) p.y = -20; ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size) });
                    requestAnimationFrame(loop);
                };
                const id = requestAnimationFrame(loop);
                return () => { window.removeEventListener('resize', resize); cancelAnimationFrame(id); };
            }, [active]);
            if (!active) return null;
            return <canvas id="confetti-canvas" ref={canvasRef} />;
        };

        function App() {
            // Theme managed globally by orfini-shared.js
            const [view, setView] = useState('menu');
            const [gameMode, setGameMode] = useState('single');
            const [nick, setNick] = useState(localStorage.getItem('mm_nick') || '');
            const [nick2, setNick2] = useState('');
            const [userAvatar, setUserAvatar] = useState(localStorage.getItem('mm_avatar') || AVATARS[0]);
            const [userAvatar2, setUserAvatar2] = useState(AVATARS[1]);
            const [soundEnabled, setSoundEnabled] = useState(localStorage.getItem('mm_sound') !== 'false');
            const [lvl, setLvl] = useState(1);
            const [scaffoldMode, setScaffoldMode] = useState(false);
            const [genConfig, setGenConfig] = useState(GENERATORS_DEF);
            const [lb, setLb] = useState(JSON.parse(localStorage.getItem('mm_lb') || '[]'));

            const [cards, setCards] = useState([]);
            const [flipped, setFlipped] = useState([]);
            const [lock, setLock] = useState(false);
            const [score, setScore] = useState(0);
            const [moves, setMoves] = useState(0);
            const [matchMsg, setMatchMsg] = useState(null);
            const [timeLeft, setTimeLeft] = useState(0);
            const [rushPhase, setRushPhase] = useState(null);
            const [multiTurn, setMultiTurn] = useState(0);
            const [multiScores, setMultiScores] = useState([0, 0]);

            const initAudio = () => { if (soundEnabled) AudioEngine.init(); };

            const startGame = () => {
                initAudio();
                if (!nick.trim()) setNick("Giocatore 1");
                if (gameMode === 'multi' && !nick2.trim()) setNick2("Giocatore 2");
                setScore(0); setMoves(0); setMultiScores([0, 0]); setMultiTurn(0);

                let newCards = generateCards(lvl, genConfig);
                if (gameMode === 'rush') {
                    setRushPhase('mem');
                    setTimeLeft(RUSH_MEM_TIME);
                    newCards = newCards.map(c => ({ ...c, isFlipped: true, seen: true })); // Se Rush, sono viste
                } else {
                    setRushPhase(null);
                }
                setCards(newCards);
                setFlipped([]); setLock(false); setMatchMsg(null);
                setView('game');
            };

            useEffect(() => {
                let timer;
                if (gameMode === 'rush' && view === 'game') {
                    if (timeLeft > 0) timer = setInterval(() => setTimeLeft(t => t - 1), 1000);
                    else {
                        if (rushPhase === 'mem') {
                            setRushPhase('play'); setTimeLeft(RUSH_PLAY_TIME);
                            setCards(c => c.map(card => ({ ...card, isFlipped: false })));
                        } else handleGameOver(false);
                    }
                }
                return () => clearInterval(timer);
            }, [timeLeft, gameMode, view, rushPhase]);

            const handleCardClick = (id) => {
                if (lock || (gameMode === 'rush' && rushPhase === 'mem')) return;
                const card = cards.find(c => c.id === id);
                if (card.isFlipped || card.isMatched) return;
                initAudio(); if (soundEnabled) AudioEngine.playFlip();

                // Segna come "seen" quando viene girata
                setCards(prev => prev.map(c => c.id === id ? { ...c, isFlipped: true, seen: true } : c));
                const newFlipped = [...flipped, id];
                setFlipped(newFlipped);

                if (newFlipped.length === 2) {
                    setLock(true);
                    if (gameMode !== 'multi') setMoves(m => m + 1);
                    checkForMatch(newFlipped);
                }
            };

            const checkForMatch = ([id1, id2]) => {
                const c1 = cards.find(c => c.id === id1);
                const c2 = cards.find(c => c.id === id2);
                const isMatch = c1.pairId === c2.pairId;

                setTimeout(() => {
                    if (isMatch) {
                        if (soundEnabled) AudioEngine.playMatch();
                        setCards(prev => prev.map(c => (c.id === id1 || c.id === id2) ? { ...c, isMatched: true, isFlipped: true } : c));
                        setMatchMsg({ text: "Corretto!", sub: EXPLANATIONS[c1.type], color: c1.color });
                        if (gameMode === 'multi') {
                            setMultiScores(s => { const n = [...s]; n[multiTurn] += 100; return n; });
                        }
                        const remaining = cards.filter(c => !c.isMatched && c.id !== id1 && c.id !== id2).length;
                        if (remaining === 0) handleGameOver(true);
                    } else {
                        if (soundEnabled) AudioEngine.playError();
                        setCards(prev => prev.map(c => (c.id === id1 || c.id === id2) ? { ...c, isFlipped: false } : c));
                        if (gameMode === 'multi') setMultiTurn(t => t === 0 ? 1 : 0);
                    }
                    setLock(false); setFlipped([]);
                    setTimeout(() => setMatchMsg(null), 2000);
                }, isMatch ? 500 : 1200);
            };

            const handleGameOver = (won) => {
                if (won && soundEnabled) AudioEngine.playWin();
                if (gameMode !== 'multi' && won) {
                    const lData = LEVELS.find(l => l.id === lvl);
                    const efficiency = lData.pairs / Math.max(lData.pairs, moves);
                    let finalScore = Math.floor(lData.points * efficiency);
                    if (scaffoldMode) finalScore = Math.floor(finalScore * 0.66);
                    setScore(finalScore);
                    const entry = { name: nick, avatar: userAvatar, score: finalScore, lvl: lData.label, date: new Date().toLocaleDateString() };
                    const newLb = [...lb, entry].sort((a, b) => b.score - a.score).slice(0, 50);
                    localStorage.setItem('mm_lb', JSON.stringify(newLb));
                    setLb(newLb);
                }
                setTimeout(() => setView(won ? 'win' : 'final'), 1000);
            };

            // RENDER
            if (view === 'menu') return (
                <div className="flex flex-col md:flex-row h-screen bg-background text-on-background">
                    <div className="w-full md:w-1/3 p-6 bg-surface border-r border-outline-variant overflow-y-auto scroller">
                        <div className="flex justify-between items-center mb-6">
                            <h1 className="text-2xl font-black">MathMatch <span className="text-primary">4.1</span></h1>
                        </div>
                        <div className="space-y-6">
                            <div className="grid grid-cols-3 gap-2">
                                {[{ id: 'single', l: 'Solo', i: Icons.User }, { id: 'rush', l: 'Rush', i: Icons.Timer }, { id: 'multi', l: '1vs1', i: Icons.Users }].map(m => (
                                    <button key={m.id} onClick={() => setGameMode(m.id)} className={`p-2 rounded-xl border-2 flex flex-col items-center ${gameMode === m.id ? 'border-primary bg-surface-container' : 'border-outline-variant bg-surface'}`}>
                                        <m.i className={gameMode === m.id ? 'text-primary' : ''} />
                                        <span className="text-xs font-bold mt-1">{m.l}</span>
                                    </button>
                                ))}
                            </div>
                            <div className="space-y-2">
                                <label className="text-xs font-bold uppercase text-on-surface-variant opacity-70">Giocatori</label>
                                <div className="flex gap-2">
                                    <button onClick={() => setUserAvatar(AVATARS[(AVATARS.indexOf(userAvatar) + 1) % AVATARS.length])} className="w-10 h-10 text-xl bg-surface-container rounded-lg flex items-center justify-center">{userAvatar}</button>
                                    <input value={nick} onChange={e => setNick(e.target.value)} placeholder="Giocatore 1" className="flex-1 bg-surface-container rounded-lg px-3 font-bold text-sm outline-none focus:ring-2 ring-primary" />
                                </div>
                                {gameMode === 'multi' && (
                                    <div className="flex gap-2">
                                        <button onClick={() => setUserAvatar2(AVATARS[(AVATARS.indexOf(userAvatar2) + 1) % AVATARS.length])} className="w-10 h-10 text-xl bg-surface-container rounded-lg flex items-center justify-center">{userAvatar2}</button>
                                        <input value={nick2} onChange={e => setNick2(e.target.value)} placeholder="Giocatore 2" className="flex-1 bg-surface-container rounded-lg px-3 font-bold text-sm outline-none focus:ring-2 ring-primary" />
                                    </div>
                                )}
                            </div>
                            <div className="space-y-2">
                                <label className="text-xs font-bold uppercase text-on-surface-variant opacity-70">Difficolt√†</label>
                                {LEVELS.map(l => (
                                    <button key={l.id} onClick={() => setLvl(l.id)} className={`w-full text-left p-3 rounded-xl border-2 flex justify-between ${lvl === l.id ? 'border-primary bg-surface-container' : 'border-outline-variant'}`}>
                                        <span className="font-bold text-sm">{l.label}</span>
                                        <span className="text-xs opacity-60">{l.desc}</span>
                                    </button>
                                ))}
                            </div>
                            <button onClick={() => setScaffoldMode(!scaffoldMode)} className={`w-full flex items-center justify-between p-3 rounded-xl border-2 ${scaffoldMode ? 'border-teal-500 bg-teal-500/10' : 'border-outline-variant'}`}>
                                <div className="flex items-center gap-2">
                                    <Icons.Ghost className={scaffoldMode ? 'text-teal-600' : 'text-on-surface-variant'} />
                                    <div className="text-left"><div className="font-bold text-xs uppercase">Scaffolding</div><div className="text-[10px]">Permanenza Testo (-33%)</div></div>
                                </div>
                                <div className={`w-4 h-4 rounded-full border ${scaffoldMode ? 'bg-teal-500 border-teal-500' : 'border-slate-300'}`} />
                            </button>
                            <button onClick={startGame} className="w-full py-4 bg-primary text-on-primary rounded-xl font-bold shadow-lg hover:opacity-90 transition-all flex justify-center gap-2">GIOCA <Icons.Play /></button>
                        </div>
                    </div>
                    <div className="flex-1 p-6 bg-surface-container overflow-y-auto scroller">
                        <h2 className="text-xl font-black mb-4 flex items-center gap-2"><Icons.Settings /> CONFIGURAZIONE DIDATTICA</h2>
                        <div className="grid md:grid-cols-2 gap-4 mb-8">
                            {Object.entries(genConfig).map(([k, c]) => (
                                <div key={k} onClick={() => setGenConfig(p => ({ ...p, [k]: { ...p[k], active: !p[k].active } }))} className={`cursor-pointer p-4 rounded-xl border-2 flex gap-3 ${c.active ? 'border-primary bg-surface' : 'border-outline-variant opacity-60'}`}>
                                    <div className={`w-5 h-5 rounded border flex items-center justify-center ${c.active ? 'bg-primary border-primary text-on-primary' : 'bg-surface border-outline-variant'}`}>{c.active && <Icon d="M20 6L9 17l-5-5" />}</div>
                                    <div>
                                        <div className="font-bold">{c.label}</div>
                                        <MathText txt={c.desc} className="text-xs opacity-70" inline={true} />
                                    </div>
                                </div>
                            ))}
                        </div>
                        <div className="bg-surface p-4 rounded-xl border border-outline-variant">
                            <div className="flex items-center gap-2 mb-2 text-primary font-bold"><Icons.Trophy /> CLASSIFICA</div>
                            {lb.slice(0, 3).map((r, i) => <div key={i} className="flex justify-between text-xs py-1 border-b border-outline-variant last:border-0"><span>{i + 1}. {r.avatar} {r.name}</span><span className="font-mono font-bold">{r.score}</span></div>)}
                        </div>
                    </div>
                </div>
            );

            // RENDER GIOCO
            if (view === 'game' || view === 'win' || view === 'final') {
                const n = cards.length;
                let gridClass = n === 6 ? "grid-cols-3" : n === 12 ? "grid-cols-4" : n === 16 ? "grid-cols-4" : "grid-cols-5";

                return (
                    <div className="h-screen flex flex-col bg-background">
                        <div className="h-16 bg-surface shadow-sm flex items-center justify-between px-4 shrink-0 z-10">
                            <button onClick={() => setView('menu')} className="text-xs font-bold text-on-surface-variant hover:text-red-500 uppercase">ESCI</button>
                            <div className="flex items-center gap-4">
                                {gameMode === 'rush' && <div className={`flex items-center gap-2 font-mono font-bold text-xl ${rushPhase === 'mem' ? 'text-yellow-600' : 'text-red-600'}`}><Icons.Timer /> {timeLeft}s</div>}
                                {gameMode === 'multi' ? (
                                    <div className="flex gap-4 items-center font-bold">
                                        <div className={`px-2 py-1 rounded ${multiTurn === 0 ? 'bg-primary text-on-primary' : ''}`}>{userAvatar} {multiScores[0]}</div>
                                        <div className="text-xs text-on-surface-variant">VS</div>
                                        <div className={`px-2 py-1 rounded ${multiTurn === 1 ? 'bg-primary text-on-primary' : ''}`}>{userAvatar2} {multiScores[1]}</div>
                                    </div>
                                ) : (
                                    <div className="flex flex-col items-end">
                                        <span className="text-[10px] text-on-surface-variant font-bold uppercase">Punti</span>
                                        <span className="font-mono font-bold text-primary text-xl">{score}</span>
                                    </div>
                                )}
                            </div>
                        </div>

                        {matchMsg && (
                            <div className={`absolute top-20 left-1/2 -translate-x-1/2 z-50 animate-bounce-short bg-surface border-2 rounded-xl px-6 py-3 shadow-xl flex items-center gap-3 ${matchMsg.color}`}>
                                <Icons.Check className="text-green-500" />
                                <div>
                                    <div className="font-black text-sm">{matchMsg.text}</div>
                                    <div className="text-xs opacity-75">{matchMsg.sub}</div>
                                </div>
                            </div>
                        )}

                        <div className="flex-1 p-4 flex items-center justify-center overflow-hidden">
                            <div className={`grid gap-3 w-full h-full max-h-[85vh] ${gridClass}`}>
                                {cards.map(c => {
                                    // STILE "SOLIDO" v2.5 per evitare salti
                                    // Bordo sempre presente sul flipper
                                    let borderColor = "border-outline-variant";
                                    let borderStyle = c.cardType === 'question' ? 'border-dashed' : 'border-solid';
                                    let bgClass = "bg-surface";

                                    if (c.isMatched) {
                                        borderColor = c.color.split(' ')[2].replace('border-', 'border-'); // Estrarre colore bordo dal preset
                                        bgClass = c.color.split(' ')[0]; // Estrarre bg
                                        borderStyle = 'border-solid';
                                    } else if (c.isFlipped) {
                                        if (c.cardType === 'question') {
                                            borderColor = "border-sky-400";
                                            bgClass = "bg-sky-50 dark:bg-sky-900/20";
                                        } else {
                                            borderColor = "border-amber-400";
                                            bgClass = "bg-amber-50 dark:bg-amber-900/20";
                                        }
                                    }

                                    return (
                                        <div key={c.id} onClick={() => handleCardClick(c.id)} className="perspective-1000 relative w-full h-full cursor-pointer group">
                                            <div className={`flipper w-full h-full shadow-sm transition-all duration-500 border-2 ${borderColor} ${borderStyle} ${bgClass} ${c.isFlipped || c.isMatched ? 'flipped' : 'hover:-translate-y-1'}`}>

                                                {/* FRONTE (COPERTA) */}
                                                <div className="face face-front flex flex-col items-center justify-center">
                                                    {/* NUOVA LOGICA SCAFFOLDING: Se attiva E carta gi√† vista, mostra contenuto */}
                                                    <div className={`opacity-${scaffoldMode && c.seen && !c.isMatched ? '100' : '0'} transition-opacity duration-300 absolute`}>
                                                        <div className="scale-75 pointer-events-none opacity-50 blur-[0.5px]">
                                                            <MathText txt={c.content} className="text-xs text-on-background" />
                                                        </div>
                                                    </div>

                                                    {/* Emoji (sparisce se girata O se scaffolding mostra contenuto) */}
                                                    <span className={`text-4xl transition-opacity duration-200 ${c.isFlipped || c.isMatched || (scaffoldMode && c.seen) ? 'opacity-0' : 'opacity-100'}`}>
                                                        {c.emoji}
                                                    </span>
                                                </div>

                                                {/* RETRO (SCOPERTA) */}
                                                <div className="face face-back flex items-center justify-center p-1">
                                                    <MathText txt={c.content} className="text-on-background font-bold text-lg md:text-2xl" />
                                                </div>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>

                        {view !== 'game' && (
                            <div className="absolute inset-0 bg-background/80 backdrop-blur-sm z-50 flex items-center justify-center">
                                <div className="bg-surface p-8 rounded-3xl shadow-2xl text-center max-w-sm w-full animate-bounce-short">
                                    <Confetti active={true} />
                                    <div className="text-6xl mb-4">{view === 'win' ? 'üèÜ' : '‚ò†Ô∏è'}</div>
                                    <h2 className="text-3xl font-black mb-2 text-on-background">{view === 'win' ? 'VITTORIA!' : 'FINE GIOCO'}</h2>
                                    <p className="text-on-surface-variant mb-6 font-bold">{score} Punti</p>
                                    <div className="grid gap-2">
                                        <button onClick={startGame} className="py-3 bg-primary text-on-primary rounded-xl font-bold shadow-lg hover:scale-105 transition-transform">RIGIOCA</button>
                                        <button onClick={() => setView('menu')} className="py-3 bg-surface-container text-on-surface-variant rounded-xl font-bold hover:bg-outline-variant transition-colors">MENU</button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                );
            }
            return null;
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>