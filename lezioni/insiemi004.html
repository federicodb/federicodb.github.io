<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    
    <!-- 1. META DATI PER CATALOGAZIONE -->
    <title>Logic Lab: Insiemi & Venn</title>
    <meta name="description" content="Laboratorio interattivo per esplorare la Teoria degli Insiemi. Definisci gli elementi, componi espressioni logiche (Unione, Intersezione) e visualizza i Diagrammi di Venn in tempo reale.">
    <meta name="keywords" content="Matematica, Logica, Insiemi, Diagrammi di Venn, 1EL, 2EL, Mat:Logica, Mat:Modellizzazione, EU:STEM, Lab">
    <meta name="date" content="2025-12-08">

    <!-- 2. FIX MOBILE -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <title>Laboratorio Logico-Insiemistico con p5.js</title>
    <!-- Tailwind CSS per lo styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Libreria p5.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        /* 3. CSS FULLSCREEN ROBUSTO */
        html, body {
            font-family: 'Inter', sans-serif;
            background-color: #000000;
            color: #e5e5e5;
            width: 100vw; height: 100dvh; /* Altezza dinamica */
            margin: 0; padding: 0;
            overflow: hidden; /* Blocca scroll pagina */
            position: fixed;
        }

        /* Contenitore scrollabile interno */
        #app-scroller {
            height: 100%; width: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding-bottom: 40px;
        }

        #venn-container { cursor: crosshair; width: 100%; display: flex; justify-content: center; }
        
        textarea { resize: none; font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; }
        
        .control-btn { transition: all 0.1s ease-in-out; font-family: 'JetBrains Mono', monospace; font-weight: 700; }
        .control-btn:active { transform: scale(0.95); filter: brightness(1.2); }
        
        /* Stile per lo switch custom */
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; flex-shrink: 0; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #374151; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #4f46e5; }
        input:checked + .slider:before { transform: translateX(22px); }
    </style>
</head>
<body>

    <!-- Wrapper Scrollabile -->
    <div id="app-scroller">
        <div class="container mx-auto p-4 max-w-6xl">
            
            <header class="flex justify-between items-center mb-6 border-b border-gray-800 pb-4">
                <div>
                    <h1 class="text-2xl md:text-3xl font-bold text-white tracking-tight">Logic Lab <span class="text-indigo-500">Venn</span></h1>
                    <p class="text-xs md:text-sm text-gray-400">Visualizzatore di Insiemi</p>
                </div>
                <a href="../index.html" class="text-xs font-bold text-gray-500 hover:text-white uppercase border border-gray-700 px-3 py-1.5 rounded transition">Esci</a>
            </header>

            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 lg:gap-8">
                
                <!-- Colonna Controlli -->
                <div class="lg:col-span-1 space-y-6">
                    
                    <!-- Definizione Insiemi -->
                    <div class="bg-gray-900/80 border border-gray-800 p-4 rounded-xl shadow-lg">
                        <div class="flex justify-between items-center mb-3">
                             <h2 class="text-sm font-bold text-gray-300 uppercase tracking-wider">Definizione</h2>
                             <button id="randomize-btn" class="text-xs bg-gray-800 hover:bg-gray-700 text-gray-300 px-3 py-1 rounded transition border border-gray-700">ðŸŽ² Random</button>
                        </div>
                        <div class="space-y-3">
                            <div class="relative">
                                <label for="setA" class="absolute -top-2 left-2 px-1 bg-gray-900 text-[10px] font-bold text-red-400">INSIEME A</label>
                                <textarea id="setA" rows="1" class="w-full bg-black/50 border border-red-900/50 rounded-lg p-2 focus:border-red-500 focus:outline-none text-red-100" placeholder="1, 2, 3...">1, 2, 3, 4, 10</textarea>
                            </div>
                            <div class="relative">
                                <label for="setB" class="absolute -top-2 left-2 px-1 bg-gray-900 text-[10px] font-bold text-green-400">INSIEME B</label>
                                <textarea id="setB" rows="1" class="w-full bg-black/50 border border-green-900/50 rounded-lg p-2 focus:border-green-500 focus:outline-none text-green-100" placeholder="3, 4, 5...">3, 4, 5, 6, 11</textarea>
                            </div>
                            <div class="relative">
                                <label for="setC" class="absolute -top-2 left-2 px-1 bg-gray-900 text-[10px] font-bold text-blue-400">INSIEME C</label>
                                <textarea id="setC" rows="1" class="w-full bg-black/50 border border-blue-900/50 rounded-lg p-2 focus:border-blue-500 focus:outline-none text-blue-100" placeholder="6, 7, 8...">4, 6, 7, 8, 12</textarea>
                            </div>
                        </div>
                    </div>

                    <!-- Operazioni Logiche -->
                    <div class="bg-gray-900/80 border border-gray-800 p-4 rounded-xl shadow-lg">
                        <h3 class="text-sm font-bold text-gray-300 uppercase tracking-wider mb-3">Espressione</h3>
                        
                        <!-- Display Espressione -->
                        <div id="expression-display" class="bg-black border border-gray-700 p-3 rounded-lg shadow-inner text-xl text-center text-white font-mono min-h-[50px] flex items-center justify-center mb-4 overflow-x-auto whitespace-nowrap">A âˆª B</div>
                        
                        <!-- Tastierino -->
                        <div class="grid grid-cols-4 gap-2 mb-2">
                            <button data-token="A" class="control-btn bg-red-900/40 text-red-400 border border-red-900 hover:bg-red-900 p-3 rounded-lg">A</button>
                            <button data-token="B" class="control-btn bg-green-900/40 text-green-400 border border-green-900 hover:bg-green-900 p-3 rounded-lg">B</button>
                            <button data-token="C" class="control-btn bg-blue-900/40 text-blue-400 border border-blue-900 hover:bg-blue-900 p-3 rounded-lg">C</button>
                            <button id="backspace-btn" class="control-btn bg-gray-800 text-gray-400 border border-gray-700 hover:bg-gray-700 p-3 rounded-lg">âŒ«</button>
                        </div>
                        <div class="grid grid-cols-4 gap-2">
                            <button data-token="âˆª" class="control-btn bg-indigo-900/40 text-indigo-300 border border-indigo-900 hover:bg-indigo-900 p-3 rounded-lg text-lg" title="Unione">âˆª</button>
                            <button data-token="âˆ©" class="control-btn bg-indigo-900/40 text-indigo-300 border border-indigo-900 hover:bg-indigo-900 p-3 rounded-lg text-lg" title="Intersezione">âˆ©</button>
                            <button data-token="\" class="control-btn bg-indigo-900/40 text-indigo-300 border border-indigo-900 hover:bg-indigo-900 p-3 rounded-lg text-lg" title="Differenza">\</button>
                            <button data-token="Î”" class="control-btn bg-indigo-900/40 text-indigo-300 border border-indigo-900 hover:bg-indigo-900 p-3 rounded-lg text-lg" title="Diff. Simmetrica">Î”</button>
                            
                            <button data-token="(" class="control-btn bg-gray-800 text-gray-300 border border-gray-700 hover:bg-gray-700 p-3 rounded-lg">(</button>
                            <button data-token=")" class="control-btn bg-gray-800 text-gray-300 border border-gray-700 hover:bg-gray-700 p-3 rounded-lg">)</button>
                            <button id="clear-expr-btn" class="control-btn bg-red-900/20 text-red-500 border border-red-900 hover:bg-red-900/40 p-3 rounded-lg text-xs col-span-2 uppercase">Clear</button>
                        </div>
                    </div>
                </div>

                <!-- Colonna Canvas & Risultati -->
                <div class="lg:col-span-2 flex flex-col gap-4">
                    
                    <!-- Area Canvas -->
                    <div class="relative bg-gray-900/50 border border-gray-800 rounded-xl overflow-hidden shadow-2xl">
                        <div id="venn-container" class="w-full h-[400px]"></div>
                        
                        <!-- Toggle Overlay -->
                        <div class="absolute top-4 right-4 bg-black/60 backdrop-blur px-3 py-2 rounded-full border border-gray-700 flex items-center gap-3">
                            <span class="text-[10px] font-bold text-gray-400 uppercase">Elementi</span>
                            <label class="switch">
                                <input type="checkbox" id="display-mode-switch">
                                <span class="slider"></span>
                            </label>
                            <span class="text-[10px] font-bold text-gray-400 uppercase">Conta</span>
                        </div>
                    </div>

                    <!-- Risultato -->
                    <div id="result-set-container" class="bg-gray-900 border border-gray-800 p-4 rounded-xl shadow-lg flex flex-col md:flex-row gap-4 items-center">
                         <div class="text-sm font-bold text-gray-500 uppercase tracking-widest md:w-32 text-center md:text-left flex-shrink-0">
                             Risultato:
                         </div>
                        <div id="result-set-display" class="flex-grow font-mono text-white text-sm md:text-base break-all bg-black/30 p-2 rounded w-full text-center md:text-left min-h-[2rem] flex items-center">
                            In attesa di calcolo...
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const sketch = (p) => {
            let setsData = {}, hoveredRegion = null, expressionTokens = ['A', 'âˆª', 'B'], lastError = null;
            let circles = {}, baseSets = { A: new Set(), B: new Set(), C: new Set() };
            let displayMode = 'elements';
            const colors = {}; 
            let blendingBuffer, maskBuffer;

            p.setup = () => {
                const container = p.select('#venn-container');
                // Altezza fissa ottimizzata, larghezza responsiva
                p.createCanvas(container.width, 400).parent(container);
                
                blendingBuffer = p.createGraphics(p.width, p.height);
                maskBuffer = p.createGraphics(p.width, p.height);
                
                colors.A = p.color(239, 68, 68);   // Red
                colors.B = p.color(34, 197, 94);   // Green
                colors.C = p.color(59, 130, 246);  // Blue
                
                p.selectAll('textarea').forEach(el => el.input(updateBaseSets));
                p.selectAll('.control-btn').forEach(btn => btn.mousePressed(() => {
                    const token = btn.attribute('data-token');
                    if (token) { expressionTokens.push(token); evaluateAndDraw(); }
                }));
                p.select('#backspace-btn').mousePressed(() => { expressionTokens.pop(); evaluateAndDraw(); });
                p.select('#clear-expr-btn').mousePressed(() => { expressionTokens = []; evaluateAndDraw(); });
                p.select('#display-mode-switch').changed((e) => { displayMode = e.target.checked ? 'cardinality' : 'elements'; evaluateAndDraw(); });
                p.select('#randomize-btn').mousePressed(randomizeSets);

                p.windowResized = () => {
                    p.resizeCanvas(container.width, 400);
                    blendingBuffer.resize(p.width, p.height);
                    maskBuffer.resize(p.width, p.height);
                    calculateGeometries();
                };

                calculateGeometries();
                updateBaseSets();
            };

            function randomizeSets() {
                const getRandomSet = (min, max, count) => {
                    const set = new Set();
                    while(set.size < count) set.add(Math.floor(Math.random() * (max - min + 1)) + min);
                    return [...set].sort((a,b)=>a-b).join(', ');
                };
                const cnt = () => Math.floor(Math.random() * 5) + 3;
                p.select('#setA').value(getRandomSet(1, 20, cnt()));
                p.select('#setB').value(getRandomSet(1, 20, cnt()));
                p.select('#setC').value(getRandomSet(1, 20, cnt()));
                updateBaseSets();
            }
            
            function updateBaseSets() {
                const parse = (text) => text ? new Set(text.split(/[\s, \n]+/).map(s => s.trim()).filter(s => s.length > 0)) : new Set();
                baseSets.A = parse(p.select('#setA').value());
                baseSets.B = parse(p.select('#setB').value());
                baseSets.C = parse(p.select('#setC').value());
                evaluateAndDraw();
            }

            function evaluateAndDraw() {
                lastError = null;
                p.select('#expression-display').html(expressionTokens.join(' ') || '&nbsp;');

                const allElements = new Set([...baseSets.A, ...baseSets.B, ...baseSets.C]);
                const regionElements = { A: [], B: [], C: [], AB: [], AC: [], BC: [], ABC: [] };
                for (const element of allElements) {
                    const inA = baseSets.A.has(element), inB = baseSets.B.has(element), inC = baseSets.C.has(element);
                    if (inA && inB && inC) regionElements.ABC.push(element);
                    else if (inA && inB) regionElements.AB.push(element);
                    else if (inA && inC) regionElements.AC.push(element);
                    else if (inB && inC) regionElements.BC.push(element);
                    else if (inA) regionElements.A.push(element);
                    else if (inB) regionElements.B.push(element);
                    else if (inC) regionElements.C.push(element);
                }
                setsData = Object.fromEntries(Object.entries(regionElements).map(([k, v]) => [k, { elements: v }]));

                const { resultSet, error } = parseAndEvaluate(expressionTokens);
                if (error) {
                    lastError = error;
                    p.select('#result-set-display').html(`<span style="color: #f87171;">${error}</span>`);
                } else {
                    const sortedElements = [...resultSet].sort((a, b) => String(a).localeCompare(String(b), undefined, {numeric: true}));
                    p.select('#result-set-display').html(sortedElements.length ? `{ ${sortedElements.join(', ')} }` : 'âˆ… (Insieme Vuoto)');
                }
            }

            function parseAndEvaluate(tokens) {
                if (tokens.length === 0) return { resultSet: new Set(), error: null };
                const precedence = { 'âˆª': 1, 'âˆ©': 2, '\\': 1, 'Î”': 1 };
                const outputQueue = [], operatorStack = [];
                for (const token of tokens) {
                    if (['A', 'B', 'C'].includes(token)) { outputQueue.push(token); }
                    else if (Object.keys(precedence).includes(token)) {
                        while (operatorStack.length > 0 && operatorStack[operatorStack.length - 1] !== '(' && precedence[operatorStack[operatorStack.length - 1]] >= precedence[token]) {
                            outputQueue.push(operatorStack.pop());
                        }
                        operatorStack.push(token);
                    } else if (token === '(') { operatorStack.push(token); }
                    else if (token === ')') {
                        while (operatorStack.length > 0 && operatorStack[operatorStack.length - 1] !== '(') { outputQueue.push(operatorStack.pop()); }
                        if (operatorStack.length === 0) return { resultSet: new Set(), error: "Parentesi non bilanciate" };
                        operatorStack.pop();
                    }
                }
                while (operatorStack.length > 0) {
                    const op = operatorStack.pop();
                    if (op === '(') return { resultSet: new Set(), error: "Parentesi non bilanciate" };
                    outputQueue.push(op);
                }
                const evalStack = [];
                for (const token of outputQueue) {
                    if (['A', 'B', 'C'].includes(token)) { evalStack.push(new Set(baseSets[token])); }
                    else {
                        if (evalStack.length < 2) return { resultSet: new Set(), error: "Operatore mancante" };
                        const b = evalStack.pop(), a = evalStack.pop();
                        let result;
                        if (token === 'âˆª') result = new Set([...a, ...b]);
                        else if (token === 'âˆ©') result = new Set([...a].filter(x => b.has(x)));
                        else if (token === '\\') result = new Set([...a].filter(x => !b.has(x)));
                        else if (token === 'Î”') result = new Set([...[...a].filter(x => !b.has(x)), ...[...b].filter(x => !a.has(x))]);
                        evalStack.push(result);
                    }
                }
                if (evalStack.length !== 1) return { resultSet: new Set(), error: "Espressione incompleta" };
                return { resultSet: evalStack[0], error: null };
            }

            p.draw = () => {
                if (p.width <= 0 || p.height <= 0) return;
                p.background(0);
                const { resultSet, error } = parseAndEvaluate(expressionTokens);
                
                if (!error && resultSet && resultSet.size > 0) {
                    drawBlendedCircles(blendingBuffer);
                    drawResultMask(maskBuffer, resultSet);
                    let finalImage = blendingBuffer.get();
                    finalImage.mask(maskBuffer);
                    p.image(finalImage, 0, 0);
                } else if (!error && resultSet) {
                    // Draw outlines even if empty result
                }
                
                determineHoveredRegion();
                drawCircleStrokes(); 
                drawRegionContent(); 
                drawTooltip();
            };
            
            function drawBlendedCircles(buffer) {
                buffer.clear(); buffer.noStroke(); buffer.blendMode(p.ADD);
                buffer.fill(colors.A); buffer.ellipse(circles.A.x, circles.A.y, circles.A.r * 2);
                buffer.fill(colors.B); buffer.ellipse(circles.B.x, circles.B.y, circles.B.r * 2);
                buffer.fill(colors.C); buffer.ellipse(circles.C.x, circles.C.y, circles.C.r * 2);
                buffer.blendMode(p.BLEND);
            }

            function drawResultMask(buffer, resultSet) {
                buffer.clear(); buffer.noStroke(); buffer.fill(255); 
                for (const regionKey in setsData) {
                    const regionElements = new Set(setsData[regionKey].elements);
                    // Logica maschera: se la regione contiene elementi che sono nel risultato, illuminala.
                    // Se la regione Ã¨ vuota ma logicamente fa parte del set (es A inter B vuoto), questo approccio visuale basato su elementi ha limiti ma Ã¨ ok per didattica.
                    // FIX: Per visualizzare regioni vuote logicamente incluse servirebbe un parser geometrico, 
                    // qui ci basiamo sugli elementi presenti.
                    if (regionElements.size > 0 && [...regionElements].every(el => resultSet.has(el))) {
                        fillDisjointRegionOnBuffer(regionKey, buffer);
                    }
                }
            }
            
            function fillDisjointRegionOnBuffer(key, targetBuffer) {
                const clip = (k) => { const c = circles[k]; targetBuffer.drawingContext.beginPath(); targetBuffer.drawingContext.arc(c.x, c.y, c.r, 0, p.TWO_PI); targetBuffer.drawingContext.clip(); };
                const erase = (k) => { const c = circles[k]; targetBuffer.erase(); targetBuffer.ellipse(c.x, c.y, c.r * 2); targetBuffer.noErase(); };
                
                targetBuffer.drawingContext.save();
                switch (key) {
                    case 'A': clip('A'); erase('B'); erase('C'); break;
                    case 'B': clip('B'); erase('A'); erase('C'); break;
                    case 'C': clip('C'); erase('A'); erase('B'); break;
                    case 'AB': clip('A'); clip('B'); erase('C'); break;
                    case 'AC': clip('A'); clip('C'); erase('B'); break;
                    case 'BC': clip('B'); clip('C'); erase('A'); break;
                    case 'ABC': clip('A'); clip('B'); clip('C'); break;
                }
                targetBuffer.rect(0, 0, targetBuffer.width, targetBuffer.height);
                targetBuffer.drawingContext.restore();
            }
            
            function calculateGeometries() {
                const w = p.width; const h = p.height; 
                // Centramento dinamico
                const r = p.min(w, h) / 3.8; 
                const cx = w/2; const cy = h/2;
                const offset = r * 0.6;
                
                circles.A = { x: cx - offset, y: cy - offset/1.5, r: r };
                circles.B = { x: cx + offset, y: cy - offset/1.5, r: r };
                circles.C = { x: cx, y: cy + offset, r: r };
            }

            function determineHoveredRegion() {
                if (p.mouseX < 0 || p.mouseX > p.width || p.mouseY < 0 || p.mouseY > p.height) { hoveredRegion = null; return; }
                const inA=p.dist(p.mouseX,p.mouseY,circles.A.x,circles.A.y)<circles.A.r, inB=p.dist(p.mouseX,p.mouseY,circles.B.x,circles.B.y)<circles.B.r, inC=p.dist(p.mouseX,p.mouseY,circles.C.x,circles.C.y)<circles.C.r;
                if(inA&&inB&&inC)hoveredRegion='ABC'; else if(inA&&inB)hoveredRegion='AB'; else if(inA&&inC)hoveredRegion='AC'; else if(inB&&inC)hoveredRegion='BC'; else if(inA)hoveredRegion='A'; else if(inB)hoveredRegion='B'; else if(inC)hoveredRegion='C'; else hoveredRegion=null;
            }

            function drawCircleStrokes() {
                p.noFill(); p.strokeWeight(2);
                const drawC = (k, col) => { p.stroke(col); p.ellipse(circles[k].x, circles[k].y, circles[k].r * 2); };
                drawC('A', p.color(200, 100, 100, 100));
                drawC('B', p.color(100, 200, 100, 100));
                drawC('C', p.color(100, 100, 200, 100));
            }

            function drawRegionContent() {
                p.textAlign(p.CENTER, p.CENTER);
                // Posizioni etichette calcolate geometricamente
                const c = circles;
                const pos = { 
                    A:{x:c.A.x-c.A.r*0.4, y:c.A.y-c.A.r*0.4}, 
                    B:{x:c.B.x+c.B.r*0.4, y:c.B.y-c.B.r*0.4}, 
                    C:{x:c.C.x, y:c.C.y+c.C.r*0.6}, 
                    AB:{x:(c.A.x+c.B.x)/2, y:c.A.y-c.A.r*0.2}, 
                    AC:{x:c.A.x+c.A.r*0.2, y:c.C.y-c.C.r*0.3}, 
                    BC:{x:c.B.x-c.B.r*0.2, y:c.C.y-c.C.r*0.3}, 
                    ABC:{x:p.width/2, y:p.height/2}
                };
                
                for (const regionKey in setsData) {
                    const elements = setsData[regionKey].elements;
                    if (elements.length > 0) {
                        p.fill(255); p.noStroke();
                        if (displayMode === 'elements') {
                            p.textSize(14); p.textStyle(p.BOLD);
                            // Semplice text wrapping o lista verticale
                            const maxItems = 4;
                            const show = elements.slice(0, maxItems);
                            const more = elements.length - maxItems;
                            let txt = show.join('\n');
                            if(more > 0) txt += `\n+${more}`;
                            p.text(txt, pos[regionKey].x, pos[regionKey].y);
                        } else { 
                            p.textSize(24); p.textStyle(p.BOLD);
                            p.text(elements.length, pos[regionKey].x, pos[regionKey].y);
                        }
                        p.textStyle(p.NORMAL);
                    }
                }
            }

            function drawTooltip() {
                if(hoveredRegion && setsData[hoveredRegion]){
                    const d=setsData[hoveredRegion], t=hoveredRegion.split('').join(' âˆ© ');
                    p.push();
                    p.translate(p.mouseX+10, p.mouseY+10);
                    p.fill(20, 20, 30, 240); p.stroke(100); p.strokeWeight(1); p.rect(0, 0, 120, 60, 8);
                    p.fill(255); p.noStroke(); p.textAlign(p.LEFT, p.TOP);
                    p.textSize(12); p.textStyle(p.BOLD); p.text(t, 10, 10);
                    p.textStyle(p.NORMAL); p.text(`Elem: ${d.elements.length}`, 10, 30);
                    p.pop();
                }
            }
        };
        new p5(sketch);
    </script>
</body>
</html>